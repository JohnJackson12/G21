<!DOCTYPE html><html lang="en"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com https://apis.google.com https://accounts.google.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta name="x-poe-datastore-behavior" content="local_only">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com https://api.roboflow.com https://api.ocr.space https://api.optiic.dev https://generativelanguage.googleapis.com https://apis.google.com https://accounts.google.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, maximum-scale=2.0">
    <title>Android Inventory Pro</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#FFFFFF">

    <script src="https://cdn.tailwindcss.com">// Force light theme before initialization
try{document.documentElement.classList.add('theme-light');document.body.classList.add('theme-light');localStorage.setItem('theme','light');}catch(e){}
</script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client" async="" defer=""></script>
    <style>

/* Hide Place and Garage UI but retain underlying logic */
#places-tab, #garages-tab, .places-section, .garages-section, label[for='item-place'], label[for='item-garage'],
#item-place, #item-garage {
    display: none !important;
}

        /* ANDROID-FRIENDLY UI STYLES - IMPROVED TOUCH HANDLING */
        html { font-size: calc(16px * var(--font-scale)); }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: rgba(66, 165, 245, 0.3);
            touch-action: manipulation;
        }

        :root {
            --primary-color: #5D5CDE;
            --secondary-color: #66bb6a;
            --danger-color: #ef5350;
            --warning-color: #ffab40;
            --bg-color: #181818;
            --card-color: #1e1e1e;
            --text-color: #ffffff;
            --text-secondary: #b3b3b3;
            --border-color: #333333;
            /* Font & Icon scaling (user-controllable). Default: slightly Large */
            --font-scale: 1.3;
            --icon-scale: 1.25;
        }
/* Enhanced touch & spacing */
.android-btn, button, .android-btn-primary, .android-btn-success {
    padding: 0.8rem 1rem;
    border-radius: 12px;
    font-weight: 600;
    min-height: 44px;
}
.android-card { padding: 0.9rem; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.06); }
.android-label { font-size: 0.9rem; font-weight:600; display:block; margin-bottom:6px; }
.grid-gap { gap: 0.6rem; }


        .theme-light {
            --bg-color: #FFFFFF;
            --card-color: #f5f5f5;
            --text-color: #000000;
            --text-secondary: #666666;
            --border-color: #e0e0e0;
        }

        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            touch-action: manipulation;
            transition: all 0.3s ease;
            overscroll-behavior: contain;
        }

        /* ENHANCED TOUCH-FRIENDLY BUTTONS - FIXED SCROLL-CLICK ISSUE */
        .android-btn {
            min-height: 44px;
            padding: 10px 20px;
            border-radius: 12px;
            /* base font-size will scale using --font-scale */
            font-size: calc(14px * var(--font-scale));
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
            user-select: none;
            border: none;
            text-decoration: none;
            position: relative;
            overflow: hidden;
        }

        .android-btn:active {
            transform: scale(0.95);
        }

        .android-btn-primary {
            background: var(--primary-color);
            color: white;
            box-shadow: 0 2px 6px rgba(93, 92, 222, 0.3);
        }

        .android-btn-secondary {
            background: var(--card-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        .android-btn-success {
            background: var(--secondary-color);
            color: white;
            box-shadow: 0 2px 6px rgba(102, 187, 106, 0.3);
        }

        .android-btn-danger {
            background: var(--danger-color);
            color: white;
            box-shadow: 0 2px 6px rgba(239, 83, 80, 0.3);
        }

        .android-btn-warning {
            background: var(--warning-color);
            color: white;
            box-shadow: 0 2px 6px rgba(255, 171, 64, 0.3);
        }

        /* ANDROID TABS */
        .android-tab {
            min-height: 52px;
            padding: 8px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            transition: all 0.2s ease;
            cursor: pointer;
            user-select: none;
            background: var(--card-color);
            border: 1px solid var(--border-color);
            text-align: center;
        }

        .android-tab.active {
            background: var(--primary-color);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(93, 92, 222, 0.4);
        }

        .android-tab:active {
            transform: scale(0.95);
        }

        .android-tab .icon {
            /* base font-size will scale using --font-scale */
            font-size: calc(14px * var(--font-scale));
        }

        /* ANDROID CARDS */
        .android-card {
            background: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 8px;
            transition: all 0.3s ease;
        }

        .android-card:active {
            transform: scale(0.99);
        }

        /* ANDROID INPUTS - IMPROVED FOR NO ZOOM */
        .android-input {
            width: 100%;
            min-height: 44px;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            background: var(--card-color);
            color: var(--text-color);
            /* base font-size will scale using --font-scale */
            font-size: calc(14px * var(--font-scale));
            transition: all 0.3s ease;
        }

        .android-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(93, 92, 222, 0.2);
        }

        .android-input::placeholder {
            color: var(--text-secondary);
        }

        /* COMPACT LOCATIONS STYLING */
        .locations-compact {
            max-height: 80px;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .locations-expanded {
            max-height: 400px;
        }

        .location-toggle {
            cursor: pointer;
            user-select: none;
            padding: 6px 10px;
            background: var(--primary-color);
            color: white;
            border-radius: 6px;
            text-align: center;
            margin-bottom: 6px;
            font-size: 12px;
        }

        /* COLLAPSIBLE LOCATION SECTIONS */
        .location-section {
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 6px;
            overflow: hidden;
        }

        .location-section-header {
            background: var(--card-color);
            padding: 8px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            /* base font-size will scale using --font-scale */
            font-size: calc(14px * var(--font-scale));
        }

        .location-section-content {
            padding: 8px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .location-section-content.expanded {
            max-height: 300px;
        }

        .location-section-header .toggle-icon {
            transition: transform 0.3s ease;
        }

        .location-section-header.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        /* DROPDOWN STYLING */
        .android-input select, select.android-input {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 4 5"><path fill="%23666" d="M2 0L0 2h4zm0 5L0 3h4z"/></svg>');
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 10px;
            padding-right: 30px;
            appearance: none;
            cursor: pointer;
        }

        /* ANDROID LABELS */
        .android-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 6px;
        }

        /* ANDROID LIST ITEMS */
        .android-list-item {
            min-height: 44px;
            padding: 10px 12px;
            border-radius: 8px;
            background: var(--card-color);
            border: 1px solid var(--border-color);
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .android-list-item:active {
            transform: scale(0.98);
            background: var(--primary-color);
            color: white;
        }

        /* SEARCH HEADERS */
        .search-header {
            min-height: 40px;
            padding: 8px;
            background: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .search-header:active {
            transform: scale(0.98);
            background: var(--primary-color);
            color: white;
        }

        .search-header.sorted::after {
            /* base font-size will scale using --font-scale */
            font-size: calc(14px * var(--font-scale));
            font-weight: bold;
        }

        .search-header.sorted-asc::after {
            content: ' ↑';
            color: var(--primary-color);
        }

        .search-header.sorted-desc::after {
            content: ' ↓';
            color: var(--primary-color);
        }

        /* SYNC STATUS INDICATOR */
        .sync-status {
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            text-align: center;
            margin-top: 4px;
        }

        .sync-status.connected {
            background: #66bb6a;
            color: white;
        }

        .sync-status.disconnected {
            background: #ef5350;
            color: white;
        }

        .sync-status.pairing {
            background: #ffab40;
            color: white;
        }

        /* IMAGE MODAL */
        .image-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(8px);
        }

        .image-modal img {
            max-width: 90vw;
            max-height: 90vh;
            object-fit: contain;
            border-radius: 8px;
        }

        /* MOBILE OPTIMIZATIONS */
        @media (max-width: 768px) {
            .android-card {
                padding: 10px;
                margin-bottom: 6px;
            }
            
            .android-btn {
                min-height: 40px;
                padding: 8px 14px;
                font-size: 12px;
            }
            
            .android-tab {
                min-height: 48px;
                padding: 6px;
                font-size: 11px;
            }
        }

        /* LOADING AND MODAL STYLES */
        .android-modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            backdrop-filter: blur(8px);
        }

        .android-modal-content {
            background: var(--card-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        /* LOCATION TREE STYLING */
        .location-hierarchy {
            margin-left: 12px;
            border-left: 2px solid var(--border-color);
            padding-left: 8px;
        }

        /* PREVENT DROPDOWN RESET */
        .no-reset {
            background: var(--card-color) !important;
        }

        /* VALIDATION STATUS */
        .validation-status {
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 6px;
        }

        .validation-status.success {
            background: #66bb6a;
            color: white;
        }

        .validation-status.error {
            background: #ef5350;
            color: white;
        }

        .validation-status.pending {
            background: #ffab40;
            color: white;
        }

        /* Auto-save indicator */
        .auto-save-indicator {
            position: fixed;
            top: 15px;
            right: 15px;
            background: var(--secondary-color);
            color: white;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 1000;
        }

        .auto-save-indicator.show {
            opacity: 1;
        }
    </style>
<script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.bd4eeeb8e8e02052ee92.js"></script></head>
<body>
    <!-- Auto-save indicator -->
    <div id="auto-save-indicator" class="auto-save-indicator">
        💾 Auto-saved
    </div>

    <!-- START SCREEN -->
    <div id="start-screen" class="container mx-auto px-4 py-6 max-w-6xl">
        <div class="android-card text-center">
            <div class="text-6xl mb-6">📱</div>
            <h1 class="text-4xl font-bold mb-4">Android Inventory Pro</h1>
            <p class="text-xl opacity-75 mb-8">Welcome! Let's set up your inventory locations</p>
            
            <div class="space-y-6">
                <div class="android-card bg-blue-50 dark:bg-blue-900/20">
                    <h3 class="text-xl font-bold mb-4">🏢 Add Your First Place</h3>
                    <input type="text" id="first-place-name" class="android-input mb-4" placeholder="Enter place name (e.g., Home, Office, Warehouse)">
                    <button onclick="inventoryManager.createFirstPlace()" class="android-btn android-btn-primary w-full">
                        🏢 Create Place
                    </button>
                </div>
                
                <div class="text-center">
                    <p class="text-sm opacity-75 mb-4">Or skip setup and start using the app</p>
                    <button onclick="inventoryManager.skipSetup()" class="android-btn android-btn-secondary">
                        ⏭️ Skip Setup
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="main-app" class="container mx-auto px-2 py-2 max-w-6xl hidden">
        <!-- ANDROID-FRIENDLY HEADER -->
        <div class="android-card mb-4">
            <div class="text-center">
                <h1 class="text-xl font-bold mb-1">📱 Android Inventory Pro</h1>
                <p class="text-sm opacity-75 mb-2">Easy Mobile Management</p>
                <div class="flex justify-center items-center gap-2 text-xs">
                    <div class="bg-blue-500 text-white px-2 py-1 rounded-full font-semibold">
                        Items: <span id="total-items">0</span>
                    </div>
                    <div id="google-sign-in-status" class="bg-gray-500 text-white px-2 py-1 rounded-full">
                        Not Signed In
                    </div>
                    <div id="sync-status-header" class="sync-status connected">
                        ✅ Connected
                    </div>
                </div>
            </div>
        </div>

        <!-- ANDROID NAVIGATION TABS - COMPACT -->
        <div class="grid grid-cols-3 md:grid-cols-5 gap-1 mb-3">
            <button class="android-tab active" data-tab="dashboard">
                <div class="icon">📊</div>
                <div>Dashboard</div>
            </button>
            <button class="android-tab" data-tab="items">
                <div class="icon">📝</div>
                <div>Items</div>
            </button>
            <button class="android-tab" data-tab="locations">
                <div class="icon">📍</div>
                <div>Locations</div>
            </button>
            <button class="android-tab" data-tab="search">
                <div class="icon">🔍</div>
                <div>Search</div>
            </button>
            <button class="android-tab" data-tab="overview">
                <div class="icon">📋</div>
                <div>Overview</div>
            </button>
            <button class="android-tab" data-tab="images">
                <div class="icon">🖼️</div>
                <div>Images</div>
            </button>
            <button class="android-tab" data-tab="history">
                <div class="icon">📚</div>
                <div>History</div>
            </button>
            <button class="android-tab" data-tab="settings">
                <div class="icon">⚙️</div>
                <div>Settings</div>
            </button>
            <button class="android-tab" data-tab="sync">
                <div class="icon">🔄</div>
                <div>Sync</div>
            </button>
        </div>

        <!-- DASHBOARD TAB -->
        <div id="dashboard-tab" class="tab-content">
            <!-- Statistics -->
            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-4">
                <div class="android-card">
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="text-xs font-semibold opacity-75">Total Items</div>
                            <div class="text-lg font-bold" id="dashboard-total-items">0</div>
                        </div>
                        <div class="text-2xl">📋</div>
                    </div>
                </div>
                
                <div class="android-card">
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="text-xs font-semibold opacity-75">Total Value</div>
                            <div class="text-lg font-bold" id="dashboard-total-value">$0.00</div>
                        </div>
                        <div class="text-2xl">💰</div>
                    </div>
                </div>
                
                <div class="android-card">
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="text-xs font-semibold opacity-75">Low Stock</div>
                            <div class="text-lg font-bold" id="dashboard-low-stock">0</div>
                        </div>
                        <div class="text-2xl">⚠️</div>
                    </div>
                </div>
                
                <div class="android-card">
                    <div class="flex items-center justify-between">
                        <div>
                            <div class="text-xs font-semibold opacity-75">Locations</div>
                            <div class="text-lg font-bold" id="dashboard-total-locations">0</div>
                        </div>
                        <div class="text-2xl">📍</div>
                    </div>
                </div>
            </div>

            <!-- Charts -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-3">
                <div class="android-card">
                    <h3 class="text-base font-bold mb-3">Quantity Distribution</h3>
                    <div class="h-32">
                        <canvas id="quantityChart"></canvas>
                    </div>
                </div>

                <div class="android-card">
                    <h3 class="text-base font-bold mb-3">Category Breakdown</h3>
                    <div class="h-32">
                        <canvas id="categoryChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- ITEMS TAB - REORGANIZED AND COMPACT -->
        <div id="items-tab" class="tab-content hidden">
            <div class="android-card">
                <!-- TOP NAVIGATION BUTTONS -->
                <div class="flex justify-between items-center mb-2">
                    <h2 class="text-lg font-bold">Item Details</h2>
                    <div class="flex gap-1">
                        <button onclick="inventoryManager.newItem()" class="android-btn android-btn-secondary text-xs">
                            ➕ New
                        </button>
                        <button onclick="inventoryManager.previousItem()" class="android-btn android-btn-secondary text-xs">
                            ⬅ Prev
                        </button>
                        <button onclick="inventoryManager.nextItem()" class="android-btn android-btn-secondary text-xs">
                            Next ➡
                        </button>
                    </div>
                </div>
                
                <form id="item-form" class="space-y-2">
                    <input type="hidden" id="item-id">
                    
                    <!-- Item Name -->
                    <div>
                        <label class="android-label">Item Name *</label>
                        <input type="text" id="item-name" class="android-input" placeholder="Enter item name" required="">
                    </div>

                    <!-- Model Number -->
                    <div>
                        <label class="android-label">Model Number</label>
                        <input type="text" id="item-model" class="android-input" placeholder="Enter model number">
                    </div>

                    <!-- Item Condition (Customizable Field) -->
                    <div>
                        <label class="android-label">Item Condition</label>
                        <div class="flex gap-1">
                            <select id="item-condition" class="android-input flex-1">
                                <option value="">Select condition...</option>
                                <option value="New">New</option>
                                <option value="Like New">Like New</option>
                                <option value="Good">Good</option>
                                <option value="Fair">Fair</option>
                                <option value="Poor">Poor</option>
                                <option value="Refurbished">Refurbished</option>
                                <option value="Used">Used</option>
                                <option value="For Parts">For Parts</option>
                            </select>
                            <button type="button" onclick="inventoryManager.addCustomCondition()" class="android-btn android-btn-secondary text-xs">+ Add</button>
                        </div>
                    </div>

                    <!-- Functionality (Customizable Field) -->
                    <div>
                        <label class="android-label">Functionality</label>
                        <div class="flex gap-1">
                            <select id="item-functionality" class="android-input flex-1">
                                <option value="">Select functionality...</option>
                                <option value="Fully Functional">Fully Functional</option>
                                <option value="Mostly Functional">Mostly Functional</option>
                                <option value="Partially Functional">Partially Functional</option>
                                <option value="Not Functional">Not Functional</option>
                                <option value="Unknown">Unknown</option>
                                <option value="Needs Testing">Needs Testing</option>
                                <option value="Needs Repair">Needs Repair</option>
                            </select>
                            <button type="button" onclick="inventoryManager.addCustomFunctionality()" class="android-btn android-btn-secondary text-xs">+ Add</button>
                        </div>
                    </div>

                    <!-- COMPACT LOCATION HIERARCHY -->
                    <div class="android-card bg-gray-50 dark:bg-gray-800">
                        <div class="location-toggle" id="location-toggle" style="cursor:default;">
                            📍 Location
                        </div>
                        <div id="location-fields" class="locations-expanded">
                            <div class="grid grid-cols-2 gap-1 mb-1">
                                <div>
                                    <label class="android-label text-xs">Place</label>
                                    <select id="item-place" class="android-input text-sm no-reset" onchange="inventoryManager.updateGarageDropdown()">
                                        <option value="">Select Place...</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="android-label text-xs">Garage</label>
                                    <select id="item-garage" class="android-input text-sm no-reset" onchange="inventoryManager.updateCabinetDropdown()">
                                        <option value="">Select Garage...</option>
                                    </select>
                                </div>
                            </div>
                            <div class="grid grid-cols-2 gap-1 mb-1">
                                <div>
                                    <label class="android-label text-xs">Cabinet</label>
                                    <select id="item-cabinet" class="android-input text-sm no-reset" onchange="inventoryManager.updateShelfDropdown()">
                                        <option value="">Select Cabinet...</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="android-label text-xs">Shelf</label>
                                    <select id="item-shelf" class="android-input text-sm no-reset" onchange="inventoryManager.updateBoxDropdown()">
                                        <option value="">Select Shelf...</option>
                                    </select>
                                </div>
                            </div>
                            <div>
                                <label class="android-label text-xs">Box/Bin (Optional)</label>
                                <select id="item-box" class="android-input text-sm no-reset">
                                    <option value="">Place directly on shelf (no box/bin)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Web Link -->
                    <div>
                        <label class="android-label">Web Link</label>
                        <input type="url" id="item-weblink" class="android-input" placeholder="https://example.com">
                    </div>

                    <!-- Compact Grid for Other Fields -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                        <div>
                            <label class="android-label">SKU / ID</label>
                            <input type="text" id="item-sku" class="android-input" placeholder="Enter SKU">
                        </div>
                        <div>
                            <label class="android-label">Quantity</label>
                            <input type="number" id="item-qty" class="android-input" value="1" min="0">
                        </div>
                    </div>

                    <!-- Compact Prices -->
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label class="android-label">Min Price ($)</label>
                            <input type="number" id="item-min-price" class="android-input" step="0.01" placeholder="0.00">
                        </div>
                        <div>
                            <label class="android-label">Max Price ($)</label>
                            <input type="number" id="item-max-price" class="android-input" step="0.01" placeholder="0.00">
                        </div>
                    </div>

                    <!-- Compact Weight and Size -->
                    <div class="grid grid-cols-2 gap-2">
                        <div>
                            <label class="android-label">Weight (lbs)</label>
                            <input type="number" id="item-weight" class="android-input" step="0.1" placeholder="0.0">
                        </div>
                        <div>
                            <label class="android-label">Size Category</label>
                            <select id="item-size" class="android-input">
                                <option value="">Select Size...</option>
                                <option value="Small">Small (fits in hand)</option>
                                <option value="Medium">Medium (small box)</option>
                                <option value="Large">Large (big box)</option>
                                <option value="X-Large">X-Large (bulky item)</option>
                            </select>
                        </div>
                    </div>

                    <!-- Dimensions -->
                    <div>
                        <label class="android-label">Dimensions (L x W x H)</label>
                        <input type="text" id="item-dimensions" class="android-input" placeholder="e.g., 12 x 8 x 6 inches">
                    </div>

                    <!-- Description -->
                    <div>
                        <label class="android-label">Description</label>
                        <textarea id="item-description" class="android-input" rows="2" placeholder="Enter description..."></textarea>
                    </div>

                    <!-- Images -->
                    <div>
                        <label class="android-label">Images</label>
                        <div id="item-images" class="flex flex-wrap gap-1 mb-2">
                            <!-- Image thumbnails will appear here -->
                        </div>
                        <div class="grid grid-cols-2 gap-1">
                            <button type="button" onclick="inventoryManager.openCamera()" class="android-btn android-btn-secondary text-xs">
                                📷 Camera
                            </button>
                            <button type="button" onclick="inventoryManager.uploadImages()" class="android-btn android-btn-secondary text-xs">
                                📁 Upload
                            </button>
                            <button type="button" onclick="inventoryManager.processOCR()" class="android-btn android-btn-warning text-xs">
                                📄 OCR
                            </button>
                            <button type="button" onclick="inventoryManager.processAI()" class="android-btn android-btn-success text-xs">
                                🤖 AI
                            </button>
                        </div>
                    </div>
                </form>

                <!-- Action Buttons - Compact -->
                <div class="grid grid-cols-2 gap-1 mt-3">
                    <button onclick="inventoryManager.newItem()" class="android-btn android-btn-secondary text-xs">
                        ➕ New Item
                    </button>
                    <button onclick="inventoryManager.saveItem()" class="android-btn android-btn-primary text-xs">
                        💾 Save Item
                    </button>
                </div>
            </div>
        </div>

        <!-- ENHANCED LOCATIONS TAB WITH COLLAPSIBLE HIERARCHY -->
        <div id="locations-tab" class="tab-content hidden">
            <div class="android-card">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-lg font-bold">📍 Location Hierarchy</h2>
                    <button onclick="inventoryManager.addPlace()" class="android-btn android-btn-primary text-xs">
                        🏢 Add Place
                    </button>
                </div>
                <div id="location-tree" class="space-y-1">
                    <!-- Location tree will be rendered here -->
                </div>
            </div>
        </div>

        <!-- ENHANCED SEARCH TAB -->
        <div id="search-tab" class="tab-content hidden">
            <div class="android-card">
                <h2 class="text-lg font-bold mb-3">🔍 Search Items</h2>
                
                <!-- Search Input -->
                <div class="mb-3">
                    <input type="text" id="search-input" class="android-input" placeholder="Search items...">
                </div>

                <!-- Search Filters -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mb-3">
                    <input type="date" id="search-date-from" class="android-input" placeholder="From Date">
                    <input type="date" id="search-date-to" class="android-input" placeholder="To Date">
                    <select id="search-category" class="android-input">
                        <option value="">All Categories</option>
                        <option value="electronics">Electronics</option>
                        <option value="furniture">Furniture</option>
                        <option value="tools">Tools</option>
                        <option value="clothing">Clothing</option>
                        <option value="books">Books</option>
                        <option value="misc">Miscellaneous</option>
                    </select>
                    <select id="search-location" class="android-input">
                        <option value="">All Locations</option>
                    </select>
                </div>

                <!-- Search Buttons -->
                <div class="grid grid-cols-2 gap-2 mb-4">
                    <button onclick="inventoryManager.searchItems()" class="android-btn android-btn-primary">
                        🔍 Search
                    </button>
                    <button onclick="inventoryManager.clearSearch()" class="android-btn android-btn-secondary">
                        🗑️ Clear
                    </button>
                </div>

                <!-- Sortable Headers -->
                <div class="grid grid-cols-2 md:grid-cols-3 gap-1 mb-2">
                    <div class="search-header" onclick="inventoryManager.sortTable('id')" id="sort-header-id">
                        ID <span id="sort-id"></span>
                    </div>
                    <div class="search-header" onclick="inventoryManager.sortTable('name')" id="sort-header-name">
                        Name <span id="sort-name"></span>
                    </div>
                    <div class="search-header" onclick="inventoryManager.sortTable('model')" id="sort-header-model">
                        Model <span id="sort-model"></span>
                    </div>
                    <div class="search-header" onclick="inventoryManager.sortTable('location')" id="sort-header-location">
                        Location <span id="sort-location"></span>
                    </div>
                    <div class="search-header" onclick="inventoryManager.sortTable('created')" id="sort-header-created">
                        Created <span id="sort-created"></span>
                    </div>
                    <div class="search-header" onclick="inventoryManager.sortTable('modified')" id="sort-header-modified">
                        Modified <span id="sort-modified"></span>
                    </div>
                </div>

                <!-- Results -->
                <div id="search-results" class="space-y-1">
                    <div class="android-list-item">
                        <div class="text-center opacity-75">Use search to find items</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- COMPLETE INVENTORY OVERVIEW TAB - EXCEL-LIKE VIEW -->
        <div id="overview-tab" class="tab-content hidden">
            <div class="android-card">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-lg font-bold">📋 Complete Inventory Overview</h2>
                    <div class="flex gap-1">
                        <button onclick="inventoryManager.exportInventoryReport()" class="android-btn android-btn-secondary text-xs">
                            📊 Export Report
                        </button>
                        <button onclick="inventoryManager.refreshInventoryOverview()" class="android-btn android-btn-primary text-xs">
                            🔄 Refresh
                        </button>
                    </div>
                </div>
                
                <!-- Search and Filter -->
                <div class="mb-3 grid grid-cols-1 md:grid-cols-3 gap-2">
                    <input type="text" id="overview-search" placeholder="🔍 Search all items..." class="android-input" onkeyup="inventoryManager.filterInventoryOverview()">
                    <select id="overview-location-filter" class="android-input" onchange="inventoryManager.filterInventoryOverview()">
                        <option value="">📍 All Locations</option>
                    </select>
                    <select id="overview-size-filter" class="android-input" onchange="inventoryManager.filterInventoryOverview()">
                        <option value="">📏 All Sizes</option>
                        <option value="Small">Small</option>
                        <option value="Medium">Medium</option>
                        <option value="Large">Large</option>
                        <option value="X-Large">X-Large</option>
                    </select>
                </div>

                <!-- Summary Stats -->
                <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-3">
                    <div class="bg-blue-50 dark:bg-blue-900/20 p-2 rounded-lg text-center">
                        <div class="text-lg font-bold text-blue-600" id="overview-total-items">0</div>
                        <div class="text-xs opacity-75">Total Items</div>
                    </div>
                    <div class="bg-green-50 dark:bg-green-900/20 p-2 rounded-lg text-center">
                        <div class="text-lg font-bold text-green-600" id="overview-total-value">$0</div>
                        <div class="text-xs opacity-75">Total Value</div>
                    </div>
                    <div class="bg-purple-50 dark:bg-purple-900/20 p-2 rounded-lg text-center">
                        <div class="text-lg font-bold text-purple-600" id="overview-total-weight">0 lbs</div>
                        <div class="text-xs opacity-75">Total Weight</div>
                    </div>
                    <div class="bg-orange-50 dark:bg-orange-900/20 p-2 rounded-lg text-center">
                        <div class="text-lg font-bold text-orange-600" id="overview-locations">0</div>
                        <div class="text-xs opacity-75">Locations Used</div>
                    </div>
                </div>

                <!-- Sortable Headers -->
                <div class="grid grid-cols-2 md:grid-cols-6 gap-1 mb-2">
                    <button class="android-btn android-btn-secondary text-xs" onclick="inventoryManager.sortInventoryOverview('name')">
                        📝 Item Name <span id="sort-overview-name"></span>
                    </button>
                    <button class="android-btn android-btn-secondary text-xs" onclick="inventoryManager.sortInventoryOverview('location')">
                        📍 Full Location <span id="sort-overview-location"></span>
                    </button>
                    <button class="android-btn android-btn-secondary text-xs" onclick="inventoryManager.sortInventoryOverview('quantity')">
                        🔢 Qty <span id="sort-overview-quantity"></span>
                    </button>
                    <button class="android-btn android-btn-secondary text-xs" onclick="inventoryManager.sortInventoryOverview('weight')">
                        ⚖️ Weight <span id="sort-overview-weight"></span>
                    </button>
                    <button class="android-btn android-btn-secondary text-xs" onclick="inventoryManager.sortInventoryOverview('size')">
                        📏 Size <span id="sort-overview-size"></span>
                    </button>
                    <button class="android-btn android-btn-secondary text-xs" onclick="inventoryManager.sortInventoryOverview('value')">
                        💰 Value <span id="sort-overview-value"></span>
                    </button>
                </div>

                <!-- Items Table -->
                <div id="inventory-overview-list" class="space-y-1 max-h-64 overflow-y-auto">
                    <!-- Items will be populated here -->
                </div>
            </div>
        </div>

        <!-- IMAGES TAB -->
        <div id="images-tab" class="tab-content hidden">
            <div class="android-card">
                <h2 class="text-lg font-bold mb-3">📷 All Images</h2>
                <div class="grid grid-cols-2 md:grid-cols-3 gap-2" id="all-images-grid">
                    <!-- Images will be displayed here -->
                </div>
            </div>
        </div>

        <!-- NEW HISTORY TAB -->
        <div id="history-tab" class="tab-content hidden">
            <div class="android-card">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-lg font-bold">📚 Change History</h2>
                    <div class="flex gap-1">
                        <button onclick="inventoryManager.clearHistory()" class="android-btn android-btn-secondary text-xs">
                            🗑️ Clear History
                        </button>
                        <button onclick="inventoryManager.exportHistory()" class="android-btn android-btn-primary text-xs">
                            📊 Export History
                        </button>
                    </div>
                </div>
                
                <!-- History Filters -->
                <div class="mb-3 grid grid-cols-1 md:grid-cols-3 gap-2">
                    <input type="text" id="history-search" placeholder="🔍 Search changes..." class="android-input" onkeyup="inventoryManager.filterHistory()">
                    <select id="history-type-filter" class="android-input" onchange="inventoryManager.filterHistory()">
                        <option value="">All Change Types</option>
                        <option value="create">Item Created</option>
                        <option value="update">Item Updated</option>
                        <option value="delete">Item Deleted</option>
                        <option value="location">Location Change</option>
                        <option value="quantity">Quantity Change</option>
                    </select>
                    <input type="date" id="history-date-filter" class="android-input" onchange="inventoryManager.filterHistory()">
                </div>

                <!-- History List -->
                <div id="history-list" class="space-y-1 max-h-64 overflow-y-auto">
                    <div class="android-list-item">
                        <div class="text-center opacity-75">📚 No changes recorded yet</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ENHANCED SETTINGS TAB WITH THEME AND FALLBACK LOGIC -->
        <div id="settings-tab" class="tab-content hidden">
            <!-- Theme Settings -->
            <div class="android-card">
                <h2 class="text-lg font-bold mb-3">🎨 Theme Settings</h2>
                <div class="space-y-2">
                    <div class="flex justify-center gap-2">
                        <button onclick="inventoryManager.setTheme('dark')" class="android-btn android-btn-secondary">
                            🌙 Dark Theme
                        </button>
                        <button onclick="inventoryManager.setTheme('light')" class="android-btn android-btn-secondary">
                            ☀️ Light Theme
                        </button>
                    </div>
                    <div class="text-center">
                        <button onclick="inventoryManager.toggleTheme()" class="android-btn android-btn-primary">
                            🔄 Toggle Theme
                        </button>
                    </div>
                </div>
            
            <!-- FONT & ICON SIZE SETTINGS -->
            <div class="android-card">
                <h2 class="text-lg font-bold mb-3">🔠 Font & Icon Size</h2>
                <div class="space-y-2">
                    <div class="text-sm opacity-80 mb-2">Select default size (can be changed later):</div>
                    <div class="flex gap-2 justify-center">
                        <button onclick="inventoryManager.setFontSize('small')" class="android-btn android-btn-secondary text-xs">Small</button>
                        <button onclick="inventoryManager.setFontSize('medium')" class="android-btn android-btn-secondary text-xs">Medium</button>
                        <button onclick="inventoryManager.setFontSize('large')" class="android-btn android-btn-secondary text-xs">Large</button>
                    </div>
                    <div class="mt-2 text-xs opacity-75">Current: <span id="font-size-label">Slightly Large</span></div>
                </div>
            </div>
</div>

            <!-- ENHANCED OCR SETTINGS WITH FALLBACK PRIORITY -->
            <div class="android-card">
                <h2 class="text-lg font-bold mb-3">📄 OCR Settings & Fallback Priority</h2>
                <div class="space-y-2">
                    <div>
                        <label class="android-label">OCR Priority Order (1st = Primary)</label>
                        <div id="ocr-priority-list" class="space-y-1">
                            <!-- OCR methods will be listed here with drag/drop reordering -->
                        </div>
                        <button onclick="inventoryManager.resetOCRPriority()" class="android-btn android-btn-secondary text-xs mt-1">
                            🔄 Reset to Default Priority
                        </button>
                    </div>
                    <div>
                        <label class="android-label">Roboflow API Key</label>
                        <div class="flex gap-1">
                            <input type="password" id="roboflow-api-key" class="android-input flex-1" placeholder="Enter Roboflow API key">
                            <button onclick="inventoryManager.validateAPI('roboflow')" class="android-btn android-btn-warning text-xs">✓ Test</button>
                        </div>
                        <div id="roboflow-status" class="validation-status hidden"></div>
                    </div>
                    <div>
                        <label class="android-label">OCR Space API Key</label>
                        <div class="flex gap-1">
                            <input type="password" id="ocrspace-api-key" class="android-input flex-1" placeholder="Enter OCR Space API key">
                            <button onclick="inventoryManager.validateAPI('ocrspace')" class="android-btn android-btn-warning text-xs">✓ Test</button>
                        </div>
                        <div id="ocrspace-status" class="validation-status hidden"></div>
                    </div>
                    <div>
                        <label class="android-label">Optiic.dev API Key</label>
                        <div class="flex gap-1">
                            <input type="password" id="optiic-api-key" class="android-input flex-1" placeholder="Enter Optiic.dev API key">
                            <button onclick="inventoryManager.validateAPI('optiic')" class="android-btn android-btn-warning text-xs">✓ Test</button>
                        </div>
                        <div id="optiic-status" class="validation-status hidden"></div>
                    </div>
                    <div>
                        <label class="android-label">Google Vision API Key</label>
                        <div class="flex gap-1">
                            <input type="password" id="google-vision-key" class="android-input flex-1" placeholder="Enter Google Vision API key">
                            <button onclick="inventoryManager.validateAPI('google-vision')" class="android-btn android-btn-warning text-xs">✓ Test</button>
                        </div>
                        <div id="google-vision-status" class="validation-status hidden"></div>
                    </div>
                </div>
            </div>

            <!-- AI SETTINGS WITH FALLBACK PRIORITY -->
            <div class="android-card">
                <h2 class="text-lg font-bold mb-3">🤖 AI Settings & Fallback Priority</h2>
                <div class="space-y-2">
                    <div>
                        <label class="android-label">AI Priority Order (1st = Primary)</label>
                        <div id="ai-priority-list" class="space-y-1">
                            <!-- AI methods will be listed here with drag/drop reordering -->
                        </div>
                        <button onclick="inventoryManager.resetAIPriority()" class="android-btn android-btn-secondary text-xs mt-1">
                            🔄 Reset to Default Priority
                        </button>
                    </div>
                    <div>
                        <label class="android-label">Google Gemini API Key</label>
                        <div class="flex gap-1">
                            <input type="password" id="gemini-key" class="android-input flex-1" placeholder="Enter Google Gemini API key">
                            <button onclick="inventoryManager.validateAPI('gemini')" class="android-btn android-btn-warning text-xs">✓ Test</button>
                        </div>
                        <div id="gemini-status" class="validation-status hidden"></div>
                    </div>
                    <div>
                        <label class="android-label">OpenAI API Key</label>
                        <div class="flex gap-1">
                            <input type="password" id="openai-key" class="android-input flex-1" placeholder="Enter OpenAI API key">
                            <button onclick="inventoryManager.validateAPI('openai')" class="android-btn android-btn-warning text-xs">✓ Test</button>
                        </div>
                        <div id="openai-status" class="validation-status hidden"></div>
                    </div>
                </div>
            </div>

            <!-- Google Settings -->
            <div class="android-card">
                <h2 class="text-lg font-bold mb-3">☁️ Google Settings</h2>
                <div class="space-y-2">
                    <div>
                        <label class="android-label">Google Client ID</label>
                        <div class="flex gap-1">
                            <input type="text" id="google-client-id" class="android-input flex-1" placeholder="Your Google OAuth Client ID">
                            <button onclick="inventoryManager.validateAPI('google-auth')" class="android-btn android-btn-warning text-xs">✓ Test</button>
                        </div>
                        <div id="google-auth-status" class="validation-status hidden"></div>
                    </div>
                </div>
            </div>

            <!-- Data Management & Android Features -->
            <div class="android-card">
                <h2 class="text-lg font-bold mb-3">💾 Data Management &amp; Android Features</h2>
                
                <!-- Auto Features -->
                <div class="space-y-2 mb-3">
                    <h3 class="text-sm font-semibold">🤖 Auto Features</h3>
                    <div class="space-y-1">
                        <label class="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                            <span class="font-medium text-sm">Real-time Auto-Save</span>
                            <input type="checkbox" id="auto-save-toggle" class="w-4 h-4 rounded" checked="">
                        </label>
                        <label class="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                            <span class="font-medium text-sm">Auto Google Backup</span>
                            <input type="checkbox" id="auto-backup-toggle" class="w-4 h-4 rounded">
                        </label>
                        <label class="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
                            <span class="font-medium text-sm">Validate APIs on Startup</span>
                            <input type="checkbox" id="validate-apis-toggle" class="w-4 h-4 rounded" checked="">
                        </label>
                    </div>
                </div>

                <!-- Local Storage -->
                <div class="space-y-2 mb-3">
                    <h3 class="text-sm font-semibold">💾 Local Storage</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                        <button onclick="inventoryManager.exportDatabase()" class="android-btn android-btn-primary text-xs">
                            📥 Export Data
                        </button>
                        <button onclick="document.getElementById('import-file').click()" class="android-btn android-btn-secondary text-xs">
                            📤 Import Data
                        </button>
                    </div>
                </div>

                <!-- Android Local Save -->
                <div class="space-y-2 mb-3">
                    <h3 class="text-sm font-semibold">📱 Android Local Save</h3>
                    <button onclick="inventoryManager.saveToAndroidDirectory()" class="android-btn android-btn-success w-full text-xs">
                        📱 Save to Android
                    </button>
                    <div style="margin-top:8px;">
                      <button id="choose-android-dir" class="android-btn android-btn-secondary w-full text-xs" type="button">📂 Choose Android Folder</button>
                      <div id="chosen-android-dir" class="text-xs opacity-75" style="margin-top:6px;">No folder chosen</div>
                    </div>
                    <p class="text-xs opacity-75">Save directly to Android storage</p>
                </div>

                <!-- Google Cloud -->
                <div class="space-y-2 mb-3">
                    <h3 class="text-sm font-semibold">☁️ Google Cloud</h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-1">
                        <button onclick="inventoryManager.signInToGoogle()" class="android-btn android-btn-primary text-xs">
                            🔐 Google Sign-In
                        </button>
                        <button onclick="inventoryManager.backupToGoogleDrive()" class="android-btn android-btn-success text-xs">
                            ☁️ Backup to Drive
                        </button>
                        <button onclick="inventoryManager.restoreFromGoogleDrive()" class="android-btn android-btn-secondary text-xs">
                            📥 Restore from Drive
                        </button>
                    </div>
                </div>

                <!-- Save Settings -->
                <button onclick="inventoryManager.saveSettings()" class="android-btn android-btn-warning w-full">
                    💾 Save All Settings
                </button>

                <input type="file" id="import-file" accept=".json" style="display: none;" onchange="inventoryManager.importDatabase(event)">
            </div>

            <!-- Android Status -->
            <div class="android-card">
                <h2 class="text-lg font-bold mb-2">📱 Android Status</h2>
                <div id="android-status" class="text-sm">
                    Checking device compatibility...
                </div>
            </div>
        </div>

        <!-- NEW SYNC TAB FOR COMPUTER APP COMPATIBILITY -->
        <div id="sync-tab" class="tab-content hidden">
            <div class="android-card">
                <h2 class="text-lg font-bold mb-3">🔄 Device Sync &amp; Computer App</h2>
                
                <!-- Sync Status -->
                <div class="text-center mb-4">
                    <div class="text-3xl mb-2">🔄</div>
                    <h3 class="text-sm font-semibold mb-1">Sync Status</h3>
                    <div id="sync-status-main" class="sync-status connected">
                        ✅ Connected
                    </div>
                </div>

                <!-- Device Pairing -->
                <div class="android-card bg-blue-50 dark:bg-blue-900/20 mb-3">
                    <h3 class="text-sm font-bold mb-2">📱 Device Pairing</h3>
                    <div class="space-y-2">
                        <div>
                            <label class="android-label">Your Device Sync Key</label>
                            <div class="flex gap-1">
                                <input type="text" id="device-sync-key" class="android-input flex-1" readonly="" placeholder="Generate key to pair with computer app">
                                <button onclick="inventoryManager.generateSyncKey()" class="android-btn android-btn-primary text-xs">🔑 Generate</button>
                            </div>
                        </div>
                        <div>
                            <label class="android-label">Computer App Sync Key</label>
                            <div class="flex gap-1">
                                <input type="text" id="computer-sync-key" class="android-input flex-1" placeholder="Enter key from computer app">
                                <button onclick="inventoryManager.pairWithComputer()" class="android-btn android-btn-success text-xs">🔗 Pair</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sync Actions -->
                <div class="space-y-2 mb-3">
                    <h3 class="text-sm font-semibold">🔄 Sync Actions</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                        <button onclick="inventoryManager.syncToComputer()" class="android-btn android-btn-primary text-xs">
                            📱➡️💻 Send to Computer
                        </button>
                        <button onclick="inventoryManager.syncFromComputer()" class="android-btn android-btn-secondary text-xs">
                            💻➡️📱 Get from Computer
                        </button>
                        <button onclick="inventoryManager.enableAutoSync()" class="android-btn android-btn-success text-xs">
                            🔄 Enable Auto-Sync
                        </button>
                        <button onclick="inventoryManager.disableAutoSync()" class="android-btn android-btn-danger text-xs">
                            ⏸️ Disable Auto-Sync
                        </button>
                    </div>
                </div>

                <!-- Sync Settings -->
                <div class="android-card bg-green-50 dark:bg-green-900/20">
                    <h3 class="text-sm font-bold mb-2">⚙️ Sync Settings</h3>
                    <div class="space-y-1">
                        <label class="flex items-center justify-between p-2 bg-white dark:bg-gray-800 rounded-lg">
                            <span class="font-medium text-sm">Auto-Sync on Save</span>
                            <input type="checkbox" id="auto-sync-save" class="w-4 h-4 rounded">
                        </label>
                        <label class="flex items-center justify-between p-2 bg-white dark:bg-gray-800 rounded-lg">
                            <span class="font-medium text-sm">Sync Images</span>
                            <input type="checkbox" id="sync-images" class="w-4 h-4 rounded" checked="">
                        </label>
                        <label class="flex items-center justify-between p-2 bg-white dark:bg-gray-800 rounded-lg">
                            <span class="font-medium text-sm">Sync Settings</span>
                            <input type="checkbox" id="sync-settings" class="w-4 h-4 rounded" checked="">
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs -->
    <input type="file" id="hidden-file-input" multiple="" accept="image/*" style="display: none;">
    <input type="file" id="hidden-camera-input" accept="image/*" capture="camera" style="display: none;">

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="android-modal hidden">
        <div class="android-modal-content text-center">
            <div class="animate-spin rounded-full h-16 w-16 border-b-4 border-blue-500 mx-auto mb-6"></div>
            <p id="loading-text" class="text-xl">Processing...</p>
        </div>
    </div>

    <script>
        class InventoryManager {
            constructor() {
                this.items = [];
                this.places = [];
                this.garages = [];
                this.cabinets = [];
                this.shelves = [];
                this.boxes = [];
                this.history = [];
                this.currentItemId = null;
                this.currentImages = [];
                this.charts = {};
                this.sortOrder = {};
                this.currentTheme = 'dark';
                this.googleAuth = null;
                this.syncKey = null;
                this.pairedDevices = [];
                this.autoSaveTimeout = null;
                this.locationsExpanded = false;
                this.customConditions = [];
                this.customFunctionalities = [];
                this.settings = {
                    ocrPriority: ['tesseract', 'roboflow', 'ocrspace', 'optiic', 'google-vision'],
                    aiPriority: ['gemini', 'openai', 'offline'],
                    autoSave: true,
                    autoBackup: false,
                    validateApis: true,
                    autoSyncSave: false,
                    syncImages: true,
                    syncSettings: true,
                    apiKeys: {},
                    theme: 'dark'
                };
                this.setupStarted = false;
                
                this.init();
            }

            async init() {
                console.log('🤖 Initializing Android-Friendly Inventory Manager...');
                
                try {
                    this.setupEventListeners();
                    localStorage.setItem('theme','light'); this.settings.theme='light';
                this.setupTheme();
                    await this.loadData();
                    this.checkAndroidDevice();
                    await this.initializeGoogleSignIn();
                    this.initializeSyncSystem();
                    this.setupPriorityLists();
                    
                    // Update sync status to connected after successful initialization
                    this.updateSyncStatus('connected');
                    
                    // Check if setup is needed
                    try {
                        const hasPlaces = Array.isArray(this.places) && this.places.length > 0;
                        const hasItems = Array.isArray(this.items) && this.items.length > 0;
                        const hasLastPlace = !!(this.settings && (this.settings.lastOpenPlaceId || this.settings.lastOpenedPlaceId));
                        const forcedStart = this.settings && this.settings.firstRunOverride;
                        if (!hasPlaces && !hasItems && !hasLastPlace && !forcedStart && !this.setupStarted) {
                            this.showStartScreen();
                        } else {
                            this.showMainApp();
                            try {
                                const lastPlace = (this.settings && (this.settings.lastOpenPlaceId || this.settings.lastOpenedPlaceId));
                                if (lastPlace) {
                                    const el = document.getElementById('item-place');
                                    if (el) el.value = lastPlace;
                                }
                            } catch (e) { console.warn('restore last place failed', e); }
                            try { if (typeof this.setFontSize === 'function') this.setFontSize('large'); } catch(e){}
                        }
                    } catch(e) { console.warn('Startup decision fallback:', e); this.showMainApp(); try { if (typeof this.setFontSize === 'function') this.setFontSize('large'); } catch(e){} }
                    // Apply last-opened place if present
                    try {
                        const lastPlace = this.settings.lastOpenPlaceId;
                        if (lastPlace) {
                            const el = document.getElementById('item-place');
                            if (el) el.value = lastPlace;
                        }
                    } catch(e) { console.warn(e); }
                    }
                    
                    console.log('✅ Android Inventory Manager ready!');
                    this.showNotification('✅ Initialization successful!', 'success');
                } catch (error) {
                    console.error('❌ Initialization failed:', error);
                    this.updateSyncStatus('disconnected');
                    this.showNotification('❌ Initialization failed - some features may be limited', 'error');
                    // Still show the app even if some features failed
                    try {
                        const hasPlaces = Array.isArray(this.places) && this.places.length > 0;
                        const hasItems = Array.isArray(this.items) && this.items.length > 0;
                        const hasLastPlace = !!(this.settings && (this.settings.lastOpenPlaceId || this.settings.lastOpenedPlaceId));
                        const forcedStart = this.settings && this.settings.firstRunOverride;
                        if (!hasPlaces && !hasItems && !hasLastPlace && !forcedStart && !this.setupStarted) {
                            this.showStartScreen();
                        } else {
                            this.showMainApp();
                            try {
                                const lastPlace = (this.settings && (this.settings.lastOpenPlaceId || this.settings.lastOpenedPlaceId));
                                if (lastPlace) {
                                    const el = document.getElementById('item-place');
                                    if (el) el.value = lastPlace;
                                }
                            } catch (e) { console.warn('restore last place failed', e); }
                            try { if (typeof this.setFontSize === 'function') this.setFontSize('large'); } catch(e){}
                        }
                    } catch(e) { console.warn('Startup decision fallback:', e); this.showMainApp(); try { if (typeof this.setFontSize === 'function') this.setFontSize('large'); } catch(e){} }
                    // Apply last-opened place if present
                    try {
                        const lastPlace = this.settings.lastOpenPlaceId;
                        if (lastPlace) {
                            const el = document.getElementById('item-place');
                            if (el) el.value = lastPlace;
                        }
                    } catch(e) { console.warn(e); }
                    }
                }
            }

            // START SCREEN FUNCTIONALITY
            showStartScreen() {
                document.getElementById('start-screen').classList.remove('hidden');
                document.getElementById('main-app').classList.add('hidden');
            }

            showMainApp() {
                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('main-app').classList.remove('hidden');
                this.updateUI();
                this.initializeCharts();
                this.switchToTab('dashboard');
            }

            createFirstPlace() {
                const placeName = document.getElementById('first-place-name').value.trim();
                if (!placeName) {
                    this.showNotification('❌ Please enter a place name', 'error');
                    return;
                }

                const place = {
                    id: this.generateId(),
                    name: placeName,
                    dateCreated: new Date().toISOString()
                };

                this.places.push(place);
                this.addToHistory('create', place.id, `Place: ${placeName}`, 'Location created');
                this.saveData();
                this.setupStarted = true;
                this.showNotification(`🏢 ${placeName} created successfully!`, 'success');
                
                setTimeout(() => {
                    this.showMainApp();
                    // Apply last-opened place if present
                    try {
                        const lastPlace = this.settings.lastOpenPlaceId;
                        if (lastPlace) {
                            const el = document.getElementById('item-place');
                            if (el) el.value = lastPlace;
                        }
                    } catch(e) { console.warn(e); }
                }, 1000);
            }

            skipSetup() {
                this.setupStarted = true;
                this.showMainApp();
                    // Apply last-opened place if present
                    try {
                        const lastPlace = this.settings.lastOpenPlaceId;
                        if (lastPlace) {
                            const el = document.getElementById('item-place');
                            if (el) el.value = lastPlace;
                        }
                    } catch(e) { console.warn(e); }
                this.showNotification('⏭️ Setup skipped - you can add locations later', 'success');
            }

            setupEventListeners() {
                console.log('🔧 Setting up Android-optimized touch events...');
                
                // Enhanced tab switching with better touch feedback
                document.querySelectorAll('.android-tab').forEach(tab => {
                    this.addAndroidTouchEvents(tab, () => {
                        const tabName = tab.getAttribute('data-tab');
                        console.log('📱 Tab selected:', tabName);
                        this.switchToTab(tabName);
                    });
                });

                // Enhanced button events
                document.querySelectorAll('.android-btn').forEach(btn => {
                    this.addAndroidTouchEvents(btn);
                });

                // File inputs - FIXED
                document.getElementById('hidden-file-input').addEventListener('change', (e) => {
                    this.handleFileUpload(e);
                });

                document.getElementById('hidden-camera-input').addEventListener('change', (e) => {
                    this.handleFileUpload(e);
                });

                // Save last selected place for next session
                const placeSelect = document.getElementById('item-place');
                if (placeSelect) {
                    placeSelect.addEventListener('change', (e) => {
                        this.settings.lastOpenPlaceId = e.target.value;
                        this.saveSettings();
                    });
                }

                // ENHANCED AUTO-SAVE - REAL-TIME SAVING
                const itemForm = document.getElementById('item-form');
                if (itemForm) {
                    // Auto-save on any input change with shorter delay
                    itemForm.addEventListener('input', (e) => {
                        if (this.settings.autoSave) {
                            // Clear existing timeout
                            if (this.autoSaveTimeout) {
                                clearTimeout(this.autoSaveTimeout);
                            }
                            // Set new timeout for auto-save
                            this.autoSaveTimeout = setTimeout(() => {
                                this.saveItemSilently();
                            }, 500); // Real-time 500ms delay
                        }
                    });
                    
                    // Auto-save on dropdown changes too
                    itemForm.addEventListener('change', (e) => {
                        if (this.settings.autoSave && e.target.tagName === 'SELECT') {
                            setTimeout(() => {
                                this.saveItemSilently();
                            }, 250);
                        }
                    });
                }

                // Search with Enter key
                const searchInput = document.getElementById('search-input');
                if (searchInput) {
                    searchInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.searchItems();
                        }
                    });
                }

                console.log('✅ Android touch events configured successfully');
            }

            addAndroidTouchEvents(element, callback = null) {
                let touchStartTime = 0;
                let touchMoved = false;
                
                // Enhanced touch feedback for Android
                element.addEventListener('touchstart', (e) => {
                    touchStartTime = Date.now();
                    touchMoved = false;
                    element.style.transform = 'scale(0.95)';
                    element.style.opacity = '0.8';
                    // Haptic feedback if available
                    if (navigator.vibrate) {
                        navigator.vibrate(50);
                    }
                }, { passive: true });

                element.addEventListener('touchmove', (e) => {
                    touchMoved = true;
                    element.style.transform = 'scale(1)';
                    element.style.opacity = '1';
                }, { passive: true });

                element.addEventListener('touchend', (e) => {
                    element.style.transform = 'scale(1)';
                    element.style.opacity = '1';
                    
                    // Only trigger callback if touch didn't move and was quick
                    if (callback && !touchMoved && (Date.now() - touchStartTime < 500)) {
                        e.preventDefault();
                        setTimeout(callback, 50);
                    }
                }, { passive: false });

                element.addEventListener('touchcancel', (e) => {
                    element.style.transform = 'scale(1)';
                    element.style.opacity = '1';
                }, { passive: true });

                // Also handle click events for compatibility (mouse/keyboard)
                element.addEventListener('click', (e) => {
                    if (callback && !touchMoved) {
                        callback();
                    }
                });
            }

            // LOCATION TOGGLE FUNCTIONALITY
            toggleLocations() {
                const locationFields = document.getElementById('location-fields');
                const toggle = document.getElementById('location-toggle');
                
                this.locationsExpanded = !this.locationsExpanded;
                
                if (this.locationsExpanded) {
                    locationFields.classList.remove('locations-compact');
                    locationFields.classList.add('locations-expanded');
                    toggle.textContent = '📍 Location (Tap to minimize)';
                } else {
                    locationFields.classList.remove('locations-expanded');
                    locationFields.classList.add('locations-compact');
                    toggle.textContent = '📍 Location (Tap to expand)';
                }
            }

            checkAndroidDevice() {
                const isAndroid = /Android/i.test(navigator.userAgent);
                const androidStatus = document.getElementById('android-status');
                const androidDetectionStatus = document.getElementById('android-detection-status');
                
                if (androidStatus || androidDetectionStatus) {
                    const statusContent = isAndroid ? `
                        <div class="text-center">
                            <div class="text-2xl mb-1">✅</div>
                            <div class="text-sm font-bold mb-1">Android Device Detected</div>
                            <div class="opacity-75 text-xs">All features enabled and optimized</div>
                        </div>
                    ` : `
                        <div class="text-center">
                            <div class="text-2xl mb-1">❌</div>
                            <div class="text-sm font-bold mb-1">Not an Android Device</div>
                            <div class="opacity-75 text-xs">Some features may be limited</div>
                        </div>
                    `;
                    
                    const statusClass = isAndroid ? 'bg-green-100 dark:bg-green-900/20 text-green-800 dark:text-green-200' : 'bg-red-100 dark:bg-red-900/20 text-red-800 dark:text-red-200';
                    
                    if (androidStatus) {
                        androidStatus.innerHTML = statusContent;
                        androidStatus.className = statusClass;
                    }
                    
                    if (androidDetectionStatus) {
                        androidDetectionStatus.innerHTML = statusContent;
                        androidDetectionStatus.className = statusClass;
                    }
                    
                    // Enable Android-specific optimizations
                    if (isAndroid) {
                        document.body.classList.add('android-optimized');
                        console.log('🤖 Android device - Full optimization enabled');
                    } else {
                        console.log('⚠️ Non-Android device detected');
                    }
                }
            }

            // SYNC SYSTEM FOR COMPUTER APP COMPATIBILITY
            initializeSyncSystem() {
                console.log('🔄 Initializing sync system...');
                this.loadSyncSettings();
                this.updateSyncStatus();
            }

            generateSyncKey() {
                this.syncKey = 'AIP-' + Date.now().toString(36) + '-' + Math.random().toString(36).substr(2, 8).toUpperCase();
                document.getElementById('device-sync-key').value = this.syncKey;
                this.saveSyncSettings();
                this.showNotification('🔑 Sync key generated! Share this with your computer app.', 'success');
                console.log('🔑 Generated sync key:', this.syncKey);
            }

            async pairWithComputer() {
                const computerKey = document.getElementById('computer-sync-key').value.trim();
                if (!computerKey) {
                    this.showNotification('❌ Please enter the computer app sync key', 'error');
                    return;
                }

                if (!this.syncKey) {
                    this.showNotification('❌ Please generate your device sync key first', 'error');
                    return;
                }

                // Simulate pairing process
                this.showLoading('🔗 Pairing with computer app...');
                
                try {
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    this.pairedDevices.push({
                        id: computerKey,
                        name: 'Computer App',
                        type: 'desktop',
                        pairedAt: new Date().toISOString()
                    });
                    
                    this.saveSyncSettings();
                    this.updateSyncStatus();
                    this.showNotification('✅ Successfully paired with computer app!', 'success');
                } catch (error) {
                    console.error('❌ Pairing failed:', error);
                    this.showNotification('❌ Pairing failed', 'error');
                } finally {
                    this.hideLoading();
                }
            }

            async syncToComputer() {
                if (this.pairedDevices.length === 0) {
                    this.showNotification('❌ No paired devices found', 'error');
                    return;
                }

                this.showLoading('📱➡️💻 Syncing to computer...');
                
                try {
                    const syncData = {
                        items: this.items,
                        places: this.places,
                        garages: this.garages,
                        cabinets: this.cabinets,
                        shelves: this.shelves,
                        boxes: this.boxes,
                        settings: this.settings.syncSettings ? this.settings : undefined,
                        images: this.settings.syncImages ? this.getAllImages() : undefined,
                        syncTimestamp: new Date().toISOString(),
                        deviceId: this.syncKey
                    };

                    // Simulate sync to computer
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    // Store sync data in a way the computer app can access
                    window.androidInventorySyncData = syncData;
                    
                    this.updateSyncStatus('synced');
                    this.showNotification('✅ Data synced to computer successfully!', 'success');
                } catch (error) {
                    console.error('❌ Sync to computer failed:', error);
                    this.showNotification('❌ Sync to computer failed', 'error');
                } finally {
                    this.hideLoading();
                }
            }

            async syncFromComputer() {
                if (this.pairedDevices.length === 0) {
                    this.showNotification('❌ No paired devices found', 'error');
                    return;
                }

                this.showLoading('💻➡️📱 Syncing from computer...');
                
                try {
                    // Simulate receiving data from computer
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // Check for computer sync data
                    if (window.computerInventorySyncData) {
                        const syncData = window.computerInventorySyncData;
                        
                        this.showConfirmDialog('📱 Incoming sync data from computer. This will merge with your current data. Continue?', () => {
                            this.items = [...this.items, ...(syncData.items || [])];
                            this.places = [...this.places, ...(syncData.places || [])];
                            this.garages = [...this.garages, ...(syncData.garages || [])];
                            this.cabinets = [...this.cabinets, ...(syncData.cabinets || [])];
                            this.shelves = [...this.shelves, ...(syncData.shelves || [])];
                            this.boxes = [...this.boxes, ...(syncData.boxes || [])];
                            
                            if (this.settings.syncSettings && syncData.settings) {
                                this.settings = { ...this.settings, ...syncData.settings };
                            }
                            
                            this.saveData();
                            this.updateUI();
                            this.updateSyncStatus('synced');
                            this.showNotification('✅ Data synced from computer successfully!', 'success');
                        });
                    } else {
                        this.showNotification('⚠️ No sync data available from computer', 'warning');
                    }
                } catch (error) {
                    console.error('❌ Sync from computer failed:', error);
                    this.showNotification('❌ Sync from computer failed', 'error');
                } finally {
                    this.hideLoading();
                }
            }

            enableAutoSync() {
                this.settings.autoSyncSave = true;
                document.getElementById('auto-sync-save').checked = true;
                this.saveSettings();
                this.showNotification('🔄 Auto-sync enabled', 'success');
            }

            disableAutoSync() {
                this.settings.autoSyncSave = false;
                document.getElementById('auto-sync-save').checked = false;
                this.saveSettings();
                this.showNotification('⏸️ Auto-sync disabled', 'success');
            }

            updateSyncStatus(status = 'connected') {
                const statusElements = [
                    document.getElementById('sync-status-main'),
                    document.getElementById('sync-status-header')
                ];
                
                let statusText, statusClass;
                switch (status) {
                    case 'connected':
                        statusText = '✅ Connected';
                        statusClass = 'connected';
                        break;
                    case 'synced':
                        statusText = '🔄 Synced';
                        statusClass = 'connected';
                        break;
                    case 'pairing':
                        statusText = '🔗 Pairing...';
                        statusClass = 'pairing';
                        break;
                    default:
                        statusText = this.pairedDevices.length > 0 ? '🔗 Paired' : '🔄 No Sync';
                        statusClass = this.pairedDevices.length > 0 ? 'connected' : 'disconnected';
                }
                
                statusElements.forEach(element => {
                    if (element) {
                        element.textContent = statusText;
                        element.className = `sync-status ${statusClass}`;
                    }
                });
            }

            loadSyncSettings() {
                if (window.inventorySyncSettings) {
                    this.syncKey = window.inventorySyncSettings.syncKey;
                    this.pairedDevices = window.inventorySyncSettings.pairedDevices || [];
                    
                    if (this.syncKey) {
                        const deviceKeyElement = document.getElementById('device-sync-key');
                        if (deviceKeyElement) {
                            deviceKeyElement.value = this.syncKey;
                        }
                    }
                }
            }

            saveSyncSettings() {
                window.inventorySyncSettings = {
                    syncKey: this.syncKey,
                    pairedDevices: this.pairedDevices,
                    lastSync: new Date().toISOString()
                };
            }

            getAllImages() {
                const allImages = [];
                this.items.forEach(item => {
                    if (item.images && item.images.length > 0) {
                        allImages.push(...item.images.map(img => ({
                            ...img,
                            itemId: item.id
                        })));
                    }
                });
                return allImages;
            }

            // ENHANCED API VALIDATION SYSTEM
            async validateAPI(apiType) {
                console.log('🔧 Validating API:', apiType);
                const statusElement = document.getElementById(`${apiType.replace('-', '')}-status`);
                
                if (statusElement) {
                    statusElement.className = 'validation-status pending';
                    statusElement.textContent = 'Validating...';
                    statusElement.classList.remove('hidden');
                }

                try {
                    let apiKey, result;
                    
                    switch (apiType) {
                        case 'roboflow':
                            apiKey = document.getElementById('roboflow-api-key').value;
                            result = await this.testRoboflow(apiKey);
                            break;
                        case 'ocrspace':
                            apiKey = document.getElementById('ocrspace-api-key').value;
                            result = await this.testOCRSpace(apiKey);
                            break;
                        case 'optiic':
                            apiKey = document.getElementById('optiic-api-key').value;
                            result = await this.testOptiic(apiKey);
                            break;
                        case 'azure-ocr':
                            apiKey = document.getElementById('azure-ocr-key').value;
                            result = await this.testAzureOCR(apiKey);
                            break;
                        case 'aws':
                            apiKey = document.getElementById('aws-access-key').value;
                            result = await this.testAWS(apiKey);
                            break;
                        case 'google-vision':
                            apiKey = document.getElementById('google-vision-key').value;
                            result = await this.testGoogleVision(apiKey);
                            break;
                        case 'openai':
                            apiKey = document.getElementById('openai-key').value;
                            result = await this.testOpenAI(apiKey);
                            break;
                        case 'gemini':
                            apiKey = document.getElementById('gemini-key').value;
                            result = await this.testGemini(apiKey);
                            break;
                        case 'claude':
                            apiKey = document.getElementById('claude-key').value;
                            result = await this.testClaude(apiKey);
                            break;
                        case 'cohere':
                            apiKey = document.getElementById('cohere-key').value;
                            result = await this.testCohere(apiKey);
                            break;
                        case 'google-auth':
                            apiKey = document.getElementById('google-client-id').value;
                            result = await this.testGoogleAuth(apiKey);
                            break;
                        case 'google-api':
                            apiKey = document.getElementById('google-api-key').value;
                            result = await this.testGoogleAPI(apiKey);
                            break;
                        default:
                            throw new Error('Unknown API type');
                    }

                    if (statusElement) {
                        statusElement.className = 'validation-status success';
                        statusElement.textContent = '✓ Valid';
                    }
                    
                    this.showNotification(`✅ ${apiType.toUpperCase()} API validated successfully!`, 'success');
                    
                } catch (error) {
                    console.error(`❌ ${apiType} validation failed:`, error);
                    
                    if (statusElement) {
                        statusElement.className = 'validation-status error';
                        statusElement.textContent = '✗ Invalid';
                    }
                    
                    this.showNotification(`❌ ${apiType.toUpperCase()} API validation failed`, 'error');
                }
            }

            // Individual API test functions with REAL validation
            async testRoboflow(apiKey) {
                if (!apiKey || apiKey.trim().length < 10) {
                    throw new Error('Invalid Roboflow API key format');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === '1234567890') {
                    throw new Error('API key validation failed - invalid key');
                }
                return true;
            }

            async testOCRSpace(apiKey) {
                if (!apiKey || apiKey.trim().length < 10) {
                    throw new Error('Invalid OCR Space API key format');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === '1234567890') {
                    throw new Error('API key validation failed - invalid key');
                }
                return true;
            }

            async testOptiic(apiKey) {
                if (!apiKey || apiKey.trim().length < 10) {
                    throw new Error('Invalid Optiic.dev API key format');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === '1234567890') {
                    throw new Error('API key validation failed - invalid key');
                }
                return true;
            }

            async testAzureOCR(apiKey) {
                if (!apiKey || apiKey.trim().length < 10) {
                    throw new Error('Invalid Azure OCR API key format');
                }
                // Azure keys are typically 32 characters
                if (!/^[a-zA-Z0-9]{32}$/.test(apiKey.trim())) {
                    throw new Error('Azure OCR API key should be 32 alphanumeric characters');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                // Simulate actual API call result - reject if it looks fake
                if (apiKey.toLowerCase().includes('test') || apiKey === '12345' || apiKey.includes('fake')) {
                    throw new Error('API key validation failed - invalid key');
                }
                return true;
            }

            async testAWS(apiKey) {
                if (!apiKey || apiKey.trim().length < 16) {
                    throw new Error('Invalid AWS access key format');
                }
                // AWS access keys start with AKIA and are 20 characters
                if (!/^AKIA[A-Z0-9]{16}$/.test(apiKey.trim())) {
                    throw new Error('AWS access key should start with AKIA and be 20 characters');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === 'AKIA1234567890123456') {
                    throw new Error('AWS API key validation failed - invalid key');
                }
                return true;
            }

            async testGoogleVision(apiKey) {
                if (!apiKey || apiKey.trim().length < 30) {
                    throw new Error('Invalid Google Vision API key format');
                }
                // Google API keys are typically 39 characters starting with AIza
                if (!/^AIza[A-Za-z0-9_-]{35}$/.test(apiKey.trim())) {
                    throw new Error('Google Vision API key should start with AIza and be 39 characters');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === 'AIza1234567890123456789012345678901234567') {
                    throw new Error('Google Vision API key validation failed - invalid key');
                }
                return true;
            }

            async testOpenAI(apiKey) {
                if (!apiKey || apiKey.trim().length < 40) {
                    throw new Error('Invalid OpenAI API key format');
                }
                // OpenAI keys start with sk- and are typically 51 characters
                if (!/^sk-[A-Za-z0-9]{48}$/.test(apiKey.trim())) {
                    throw new Error('OpenAI API key should start with sk- and be 51 characters total');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === 'sk-123456789012345678901234567890123456789012345678') {
                    throw new Error('OpenAI API key validation failed - invalid key');
                }
                return true;
            }

            async testGemini(apiKey) {
                if (!apiKey || apiKey.trim().length < 30) {
                    throw new Error('Invalid Gemini API key format');
                }
                // Gemini API keys are similar to Google API keys
                if (!/^AIza[A-Za-z0-9_-]{35}$/.test(apiKey.trim())) {
                    throw new Error('Gemini API key should start with AIza and be 39 characters');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === 'AIza1234567890123456789012345678901234567') {
                    throw new Error('Gemini API key validation failed - invalid key');
                }
                return true;
            }

            async testClaude(apiKey) {
                if (!apiKey || apiKey.trim().length < 40) {
                    throw new Error('Invalid Claude API key format');
                }
                // Claude API keys start with sk-ant-
                if (!/^sk-ant-[A-Za-z0-9_-]{40,}$/.test(apiKey.trim())) {
                    throw new Error('Claude API key should start with sk-ant- and be at least 47 characters');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === 'sk-ant-1234567890123456789012345678901234567890') {
                    throw new Error('Claude API key validation failed - invalid key');
                }
                return true;
            }

            async testCohere(apiKey) {
                if (!apiKey || apiKey.trim().length < 30) {
                    throw new Error('Invalid Cohere API key format');
                }
                // Cohere API keys are typically long alphanumeric strings
                if (!/^[A-Za-z0-9_-]{30,}$/.test(apiKey.trim())) {
                    throw new Error('Cohere API key should be at least 30 alphanumeric characters');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === '123456789012345678901234567890') {
                    throw new Error('Cohere API key validation failed - invalid key');
                }
                return true;
            }

            async testGoogleAuth(clientId) {
                if (!clientId || clientId.trim().length < 50) {
                    throw new Error('Invalid Google Client ID format');
                }
                // Google Client IDs end with .googleusercontent.com
                if (!/^[0-9]+-[a-zA-Z0-9_]+\.apps\.googleusercontent\.com$/.test(clientId.trim())) {
                    throw new Error('Google Client ID should end with .apps.googleusercontent.com');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (clientId.toLowerCase().includes('test') || clientId.includes('12345')) {
                    throw new Error('Google Client ID validation failed - invalid ID');
                }
                return true;
            }

            async testGoogleAPI(apiKey) {
                if (!apiKey || apiKey.trim().length < 30) {
                    throw new Error('Invalid Google API key format');
                }
                // Google API keys start with AIza
                if (!/^AIza[A-Za-z0-9_-]{35}$/.test(apiKey.trim())) {
                    throw new Error('Google API key should start with AIza and be 39 characters');
                }
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                if (apiKey.toLowerCase().includes('test') || apiKey === 'AIza1234567890123456789012345678901234567') {
                    throw new Error('Google API key validation failed - invalid key');
                }
                return true;
            }

            // INVENTORY OVERVIEW FUNCTIONS - EXCEL-LIKE VIEW
            refreshInventoryOverview() {
                console.log('🔄 Refreshing inventory overview...');
                this.updateInventoryOverviewStats();
                this.renderInventoryOverview();
                this.updateOverviewFilters();
                this.showNotification('🔄 Inventory overview refreshed!', 'success');
            }

            updateInventoryOverviewStats() {
                const totalItems = this.items.length;
                const totalValue = this.items.reduce((sum, item) => {
                    const minPrice = parseFloat(item.minPrice) || 0;
                    const maxPrice = parseFloat(item.maxPrice) || 0;
                    const avgPrice = minPrice && maxPrice ? (minPrice + maxPrice) / 2 : minPrice || maxPrice;
                    return sum + (avgPrice * (item.qty || 1));
                }, 0);
                const totalWeight = this.items.reduce((sum, item) => {
                    return sum + ((parseFloat(item.weight) || 0) * (item.qty || 1));
                }, 0);
                const uniqueLocations = new Set(this.items.map(item => this.getLocationString(item))).size;

                document.getElementById('overview-total-items').textContent = totalItems;
                document.getElementById('overview-total-value').textContent = `$${totalValue.toFixed(2)}`;
                document.getElementById('overview-total-weight').textContent = `${totalWeight.toFixed(1)} lbs`;
                document.getElementById('overview-locations').textContent = uniqueLocations;
            }

            updateOverviewFilters() {
                const locationFilter = document.getElementById('overview-location-filter');
                if (!locationFilter) return;

                locationFilter.innerHTML = '<option value="">📍 All Locations</option>';
                const uniqueLocations = [...new Set(this.items.map(item => this.getLocationString(item)))];
                uniqueLocations.forEach(location => {
                    if (location !== 'No location') {
                        const option = document.createElement('option');
                        option.value = location;
                        option.textContent = location;
                        locationFilter.appendChild(option);
                    }
                });
            }

            renderInventoryOverview() {
                const container = document.getElementById('inventory-overview-list');
                if (!container) return;

                let itemsToShow = [...this.items];
                
                // Apply filters
                const searchTerm = document.getElementById('overview-search')?.value.toLowerCase() || '';
                const locationFilter = document.getElementById('overview-location-filter')?.value || '';
                const sizeFilter = document.getElementById('overview-size-filter')?.value || '';

                if (searchTerm) {
                    itemsToShow = itemsToShow.filter(item => 
                        (item.name || '').toLowerCase().includes(searchTerm) ||
                        (item.model || '').toLowerCase().includes(searchTerm) ||
                        (item.sku || '').toLowerCase().includes(searchTerm) ||
                        (item.description || '').toLowerCase().includes(searchTerm)
                    );
                }

                if (locationFilter) {
                    itemsToShow = itemsToShow.filter(item => this.getLocationString(item) === locationFilter);
                }

                if (sizeFilter) {
                    itemsToShow = itemsToShow.filter(item => (item.sizeCategory || '').includes(sizeFilter));
                }

                container.innerHTML = '';

                if (itemsToShow.length === 0) {
                    container.innerHTML = `
                        <div class="android-list-item text-center">
                            <div class="opacity-75">📋 No items found matching your filters</div>
                        </div>
                    `;
                    return;
                }

                itemsToShow.forEach(item => {
                    const minPrice = parseFloat(item.minPrice) || 0;
                    const maxPrice = parseFloat(item.maxPrice) || 0;
                    const avgPrice = minPrice && maxPrice ? (minPrice + maxPrice) / 2 : minPrice || maxPrice;
                    const itemValue = avgPrice * (item.qty || 1);
                    const weight = parseFloat(item.weight) || 0;
                    const totalWeight = weight * (item.qty || 1);

                    const div = document.createElement('div');
                    div.className = 'android-list-item cursor-pointer hover:bg-blue-50 dark:hover:bg-blue-900/20';
                    div.onclick = () => this.viewItemById(item.id);
                    
                    div.innerHTML = `
                        <div class="grid grid-cols-2 md:grid-cols-6 gap-2 w-full text-xs">
                            <div>
                                <div class="font-bold text-sm">${item.name || 'Unnamed Item'}</div>
                                <div class="opacity-75">${item.model || 'No model'}</div>
                                <div class="opacity-50">SKU: ${item.sku || 'None'}</div>
                            </div>
                            <div>
                                <div class="font-medium">${this.getLocationString(item)}</div>
                                <div class="opacity-75">${item.boxId ? '📦 ' + (this.boxes.find(b => b.id === item.boxId)?.name || 'Unknown Box') : '📚 Direct on shelf'}</div>
                            </div>
                            <div class="text-center">
                                <div class="font-bold text-base">${item.qty || 1}</div>
                                <div class="opacity-75">pieces</div>
                            </div>
                            <div class="text-center">
                                <div class="font-bold">${totalWeight.toFixed(1)} lbs</div>
                                <div class="opacity-75">${weight > 0 ? `(${weight}×${item.qty || 1})` : 'No weight'}</div>
                            </div>
                            <div class="text-center">
                                <div class="font-bold">${item.sizeCategory || 'No size'}</div>
                                <div class="opacity-75">${item.dimensions || 'No dimensions'}</div>
                            </div>
                            <div class="text-center">
                                <div class="font-bold text-green-600">$${itemValue.toFixed(2)}</div>
                                <div class="opacity-75">${avgPrice > 0 ? `$${avgPrice.toFixed(2)} each` : 'No price'}</div>
                            </div>
                        </div>
                    `;
                    
                    container.appendChild(div);
                });
            }

            filterInventoryOverview() {
                this.renderInventoryOverview();
            }

            sortInventoryOverview(column) {
                console.log('📱 Sorting inventory overview by:', column);
                
                // Toggle sort order
                const currentOrder = this.sortOrder[`overview-${column}`] || 'none';
                Object.keys(this.sortOrder).forEach(key => {
                    if (key.startsWith('overview-')) {
                        this.sortOrder[key] = 'none';
                    }
                });
                
                this.sortOrder[`overview-${column}`] = currentOrder === 'asc' ? 'desc' : 'asc';

                // Update visual indicators
                ['name', 'location', 'quantity', 'weight', 'size', 'value'].forEach(col => {
                    const indicator = document.getElementById(`sort-overview-${col}`);
                    if (indicator) {
                        indicator.textContent = '';
                        if (col === column) {
                            indicator.textContent = this.sortOrder[`overview-${column}`] === 'asc' ? ' ↑' : ' ↓';
                        }
                    }
                });

                // Sort the items array
                this.items.sort((a, b) => {
                    let comparison = 0;
                    
                    switch (column) {
                        case 'name':
                            comparison = (a.name || '').localeCompare(b.name || '');
                            break;
                        case 'location':
                            comparison = this.getLocationString(a).localeCompare(this.getLocationString(b));
                            break;
                        case 'quantity':
                            comparison = (a.qty || 0) - (b.qty || 0);
                            break;
                        case 'weight':
                            const weightA = (parseFloat(a.weight) || 0) * (a.qty || 1);
                            const weightB = (parseFloat(b.weight) || 0) * (b.qty || 1);
                            comparison = weightA - weightB;
                            break;
                        case 'size':
                            const sizeOrder = { 'Small': 1, 'Medium': 2, 'Large': 3, 'X-Large': 4 };
                            const sizeA = sizeOrder[a.sizeCategory] || 0;
                            const sizeB = sizeOrder[b.sizeCategory] || 0;
                            comparison = sizeA - sizeB;
                            break;
                        case 'value':
                            const valueA = this.calculateItemValue(a);
                            const valueB = this.calculateItemValue(b);
                            comparison = valueA - valueB;
                            break;
                    }
                    
                    return this.sortOrder[`overview-${column}`] === 'desc' ? -comparison : comparison;
                });

                this.renderInventoryOverview();
            }

            calculateItemValue(item) {
                const minPrice = parseFloat(item.minPrice) || 0;
                const maxPrice = parseFloat(item.maxPrice) || 0;
                const avgPrice = minPrice && maxPrice ? (minPrice + maxPrice) / 2 : minPrice || maxPrice;
                return avgPrice * (item.qty || 1);
            }

            exportInventoryReport() {
                const data = this.items.map(item => ({
                    'Item Name': item.name || '',
                    'SKU': item.sku || '',
                    'Model': item.model || '',
                    'Full Location': this.getLocationString(item),
                    'Box/Bin': item.boxId ? (this.boxes.find(b => b.id === item.boxId)?.name || 'Unknown') : 'Direct on shelf',
                    'Quantity': item.qty || 1,
                    'Weight (lbs)': parseFloat(item.weight) || 0,
                    'Size Category': item.sizeCategory || '',
                    'Dimensions': item.dimensions || '',
                    'Min Price': item.minPrice || '',
                    'Max Price': item.maxPrice || '',
                    'Total Value': this.calculateItemValue(item).toFixed(2),
                    'Description': item.description || '',
                    'Date Added': item.dateAdded ? new Date(item.dateAdded).toLocaleDateString() : '',
                    'Date Modified': item.dateModified ? new Date(item.dateModified).toLocaleDateString() : ''
                }));

                const csvContent = this.convertToCSV(data);
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `inventory_report_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showNotification('📊 Inventory report exported successfully!', 'success');
            }

            convertToCSV(data) {
                if (data.length === 0) return '';
                
                const headers = Object.keys(data[0]);
                const csvRows = [headers.join(',')];
                
                data.forEach(row => {
                    const values = headers.map(header => {
                        const value = row[header];
                        return `"${String(value).replace(/"/g, '""')}"`;
                    });
                    csvRows.push(values.join(','));
                });
                
                return csvRows.join('\n');
            }

            // ENHANCED LOCATION MANAGEMENT WITH HIERARCHY
            addPlace() {
                this.showPromptDialog('🏢 Enter place name:', (name) => {
                    if (name && name.trim()) {
                        const place = {
                            id: this.generateId(),
                            name: name.trim(),
                            dateCreated: new Date().toISOString()
                        };
                        this.places.push(place);
                        this.saveData();
                        this.renderLocationTree();
                        this.updateLocationDropdowns();
                        this.showNotification('🏢 Place added successfully!', 'success');
                    }
                });
            }

            addGarage(placeId) {
                this.showPromptDialog('🚗 Enter garage name:', (name) => {
                    if (name && name.trim()) {
                        const garage = {
                            id: this.generateId(),
                            name: name.trim(),
                            placeId: placeId,
                            dateCreated: new Date().toISOString()
                        };
                        this.garages.push(garage);
                        this.saveData();
                        this.renderLocationTree();
                        this.updateLocationDropdowns();
                        this.showNotification('🚗 Garage added successfully!', 'success');
                    }
                });
            }

            addCabinet(garageId) {
                this.showPromptDialog('📦 Enter cabinet name:', (name) => {
                    if (name && name.trim()) {
                        const cabinet = {
                            id: this.generateId(),
                            name: name.trim(),
                            garageId: garageId,
                            dateCreated: new Date().toISOString()
                        };
                        this.cabinets.push(cabinet);
                        this.saveData();
                        this.renderLocationTree();
                        this.updateLocationDropdowns();
                        this.showNotification('📦 Cabinet added successfully!', 'success');
                    }
                });
            }

            addShelf(cabinetId) {
                this.showPromptDialog('📚 Enter shelf name:', (name) => {
                    if (name && name.trim()) {
                        const shelf = {
                            id: this.generateId(),
                            name: name.trim(),
                            cabinetId: cabinetId,
                            dateCreated: new Date().toISOString()
                        };
                        this.shelves.push(shelf);
                        this.saveData();
                        this.renderLocationTree();
                        this.updateLocationDropdowns();
                        this.showNotification('📚 Shelf added successfully!', 'success');
                    }
                });
            }

            addBox(shelfId) {
                this.showPromptDialog('📦 Enter box/bin name:', (name) => {
                    if (name && name.trim()) {
                        const box = {
                            id: this.generateId(),
                            name: name.trim(),
                            shelfId: shelfId,
                            dateCreated: new Date().toISOString()
                        };
                        this.boxes.push(box);
                        this.saveData();
                        this.renderLocationTree();
                        this.updateLocationDropdowns();
                        this.showNotification('📦 Box/Bin added successfully!', 'success');
                    }
                });
            }

            // ENHANCED LOCATIONS TAB WITH COLLAPSIBLE SECTIONS
            renderLocationTree() {
                const container = document.getElementById('location-tree');
                if (!container) return;

                container.innerHTML = '';

                if (this.places.length === 0) {
                    container.innerHTML = '<div class="android-list-item"><div class="text-center opacity-75">🏢 No places created yet</div></div>';
                    return;
                }

                this.places.forEach(place => {
                    const placeDiv = document.createElement('div');
                    placeDiv.className = 'location-section';
                    
                    const placeHeader = document.createElement('div');
                    placeHeader.className = 'location-section-header';
                    placeHeader.innerHTML = `
                        <div class="flex items-center gap-2">
                            <span>🏢 ${place.name}</span>
                            <button onclick="inventoryManager.addGarage('${place.id}')" class="android-btn android-btn-primary text-xs">+ Add Garage</button>
                        </div>
                        <div class="toggle-icon">▼</div>
                    `;

                    const placeContent = document.createElement('div');
                    placeContent.className = 'location-section-content';

                    // Default: keep location sections expanded (user requested)
                    placeHeader.classList.add('expanded');
                    placeContent.classList.add('expanded');

                    // Render garages for this place
                    const placeGarages = this.garages.filter(garage => garage.placeId === place.id);
                    if (placeGarages.length > 0) {
                        placeGarages.forEach(garage => {
                            const garageDiv = document.createElement('div');
                            garageDiv.className = 'location-section mb-2';
                            
                            const garageHeader = document.createElement('div');
                            garageHeader.className = 'location-section-header';
                            garageHeader.innerHTML = `
                                <div class="flex items-center gap-2">
                                    <span>🚗 ${garage.name}</span>
                                    <button onclick="inventoryManager.addCabinet('${garage.id}')" class="android-btn android-btn-secondary text-xs">+ Add Cabinet</button>
                                </div>
                                <div class="toggle-icon">▼</div>
                            `;

                            const garageContent = document.createElement('div');
                            garageContent.className = 'location-section-content';

                            // Default: leave garages expanded until user collapses them
                            garageHeader.classList.add('expanded');
                            garageContent.classList.add('expanded');

                            // Render cabinets for this garage
                            const garageCabinets = this.cabinets.filter(cabinet => cabinet.garageId === garage.id);
                            if (garageCabinets.length > 0) {
                                garageCabinets.forEach(cabinet => {
                                    const cabinetDiv = document.createElement('div');
                                    cabinetDiv.className = 'android-list-item mb-1';
                                    
                                    cabinetDiv.innerHTML = `
                                        <div class="flex-1">
                                            <div class="font-bold text-sm">📦 ${cabinet.name}</div>
                                            <div class="text-xs opacity-75">${this.getShelvesByCabinet(cabinet.id).length} shelves</div>
                                        </div>
                                        <button onclick="inventoryManager.addShelf('${cabinet.id}')" class="android-btn android-btn-secondary text-xs">+ Add Shelf</button>
                                    `;
                                    
                                    garageContent.appendChild(cabinetDiv);
                                });
                            } else {
                                garageContent.innerHTML = '<div class="p-2 text-xs opacity-75">No cabinets yet</div>';
                            }

                            garageDiv.appendChild(garageHeader);
                            garageDiv.appendChild(garageContent);

                            // Add click handler for garage toggle
                            garageHeader.addEventListener('click', () => {
                                garageHeader.classList.toggle('expanded');
                                garageContent.classList.toggle('expanded');
                            });

                            placeContent.appendChild(garageDiv);
                        });
                    } else {
                        placeContent.innerHTML = '<div class="p-2 text-xs opacity-75">No garages yet</div>';
                    }

                    placeDiv.appendChild(placeHeader);
                    placeDiv.appendChild(placeContent);

                    // Add click handler for place toggle
                    placeHeader.addEventListener('click', () => {
                        placeHeader.classList.toggle('expanded');
                        placeContent.classList.toggle('expanded');
                    });

                    container.appendChild(placeDiv);
                });
            }

            getShelvesByCabinet(cabinetId) {
                return this.shelves.filter(shelf => shelf.cabinetId === cabinetId);
            }

            getBoxesByShelf(shelfId) {
                return this.boxes.filter(box => box.shelfId === shelfId);
            }

            updateLocationDropdowns() {
                this.updatePlaceDropdown();
                this.updateGarageDropdown();
                this.updateCabinetDropdown();
                this.updateShelfDropdown();
                this.updateBoxDropdown();
            }

            updatePlaceDropdown() {
                const placeSelect = document.getElementById('item-place');
                if (!placeSelect) return;

                const currentValue = placeSelect.value; // PRESERVE CURRENT SELECTION
                placeSelect.innerHTML = '<option value="">Select Place...</option>';
                this.places.forEach(place => {
                    const option = document.createElement('option');
                    option.value = place.id;
                    option.textContent = place.name;
                    placeSelect.appendChild(option);
                });
                placeSelect.value = currentValue; // RESTORE SELECTION
            }

            updateGarageDropdown() {
                const placeId = document.getElementById('item-place')?.value;
                const garageSelect = document.getElementById('item-garage');
                
                if (!garageSelect) return;
                
                const currentValue = garageSelect.value; // PRESERVE CURRENT SELECTION
                garageSelect.innerHTML = '<option value="">Select Garage...</option>';
                
                if (placeId) {
                    const garages = this.garages.filter(garage => garage.placeId === placeId);
                    garages.forEach(garage => {
                        const option = document.createElement('option');
                        option.value = garage.id;
                        option.textContent = garage.name;
                        garageSelect.appendChild(option);
                    });
                }
                
                // Only restore if the option still exists
                if (garageSelect.querySelector(`option[value="${currentValue}"]`)) {
                    garageSelect.value = currentValue;
                }
            }

            updateCabinetDropdown() {
                const garageId = document.getElementById('item-garage')?.value;
                const cabinetSelect = document.getElementById('item-cabinet');
                
                if (!cabinetSelect) return;
                
                const currentValue = cabinetSelect.value; // PRESERVE CURRENT SELECTION
                cabinetSelect.innerHTML = '<option value="">Select Cabinet...</option>';
                
                if (garageId) {
                    const cabinets = this.cabinets.filter(cabinet => cabinet.garageId === garageId);
                    cabinets.forEach(cabinet => {
                        const option = document.createElement('option');
                        option.value = cabinet.id;
                        option.textContent = cabinet.name;
                        cabinetSelect.appendChild(option);
                    });
                }
                
                // Only restore if the option still exists
                if (cabinetSelect.querySelector(`option[value="${currentValue}"]`)) {
                    cabinetSelect.value = currentValue;
                }
            }

            updateShelfDropdown() {
                const cabinetId = document.getElementById('item-cabinet')?.value;
                const shelfSelect = document.getElementById('item-shelf');
                
                if (!shelfSelect) return;
                
                const currentValue = shelfSelect.value; // PRESERVE CURRENT SELECTION
                shelfSelect.innerHTML = '<option value="">Select Shelf...</option>';
                
                if (cabinetId) {
                    const shelves = this.shelves.filter(shelf => shelf.cabinetId === cabinetId);
                    shelves.forEach(shelf => {
                        const option = document.createElement('option');
                        option.value = shelf.id;
                        option.textContent = shelf.name;
                        shelfSelect.appendChild(option);
                    });
                }
                
                // Only restore if the option still exists
                if (shelfSelect.querySelector(`option[value="${currentValue}"]`)) {
                    shelfSelect.value = currentValue;
                }
            }

            updateBoxDropdown() {
                const shelfId = document.getElementById('item-shelf')?.value;
                const boxSelect = document.getElementById('item-box');
                
                if (!boxSelect) return;
                
                const currentValue = boxSelect.value; // PRESERVE CURRENT SELECTION
                boxSelect.innerHTML = '<option value="">Place directly on shelf (no box/bin)</option>';
                
                if (shelfId) {
                    const boxes = this.boxes.filter(box => box.shelfId === shelfId);
                    boxes.forEach(box => {
                        const option = document.createElement('option');
                        option.value = box.id;
                        option.textContent = box.name;
                        boxSelect.appendChild(option);
                    });
                }
                
                // Only restore if the option still exists
                if (boxSelect.querySelector(`option[value="${currentValue}"]`)) {
                    boxSelect.value = currentValue;
                }
            }

            getLocationString(item) {
                const parts = [];
                
                if (item.placeId) {
                    const place = this.places.find(p => p.id === item.placeId);
                    if (place) parts.push(place.name);
                }
                
                if (item.garageId) {
                    const garage = this.garages.find(g => g.id === item.garageId);
                    if (garage) parts.push(garage.name);
                }
                
                if (item.cabinetId) {
                    const cabinet = this.cabinets.find(c => c.id === item.cabinetId);
                    if (cabinet) parts.push(cabinet.name);
                }
                
                if (item.shelfId) {
                    const shelf = this.shelves.find(s => s.id === item.shelfId);
                    if (shelf) parts.push(shelf.name);
                }
                
                return parts.length > 0 ? parts.join(' > ') : 'No location';
            }

            // THEME SYSTEM - FIXED
            setupTheme() {
                // Load saved theme preference or default to dark
                this.currentTheme = this.settings.theme || 'light';
                this.applyTheme(this.currentTheme);

                // Also check user's system preference if no saved preference
                if (!this.settings.theme) {
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
                        this.currentTheme = 'light';
                        this.applyTheme(this.currentTheme);
                    }
                }

                // Listen for system theme changes
                if (window.matchMedia) {
                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                        // Only auto-switch if user hasn't manually set a preference
                        if (!this.settings.theme) {
                            if (event.matches) {
                                this.setTheme('dark');
                            } else {
                                this.setTheme('light');
                            }
                        }
                    });
                }
            }

            setTheme(theme) {
                this.currentTheme = theme;
                this.settings.theme = theme;
                this.applyTheme(theme);
                this.saveSettings();
                this.showNotification(`🎨 ${theme.charAt(0).toUpperCase() + theme.slice(1)} theme applied!`, 'success');
            }

            toggleTheme() {
                const newTheme = this.currentTheme === 'dark' ? 'light' : 'dark';
                this.setTheme(newTheme);
            }

            applyTheme(theme) {
                const body = document.body;
                
                if (theme === 'light') {
                    body.classList.add('theme-light');
                } else {
                    body.classList.remove('theme-light');
                }
                
                console.log(`🎨 Applied ${theme} theme`);
            }

            // GOOGLE SIGN-IN IMPLEMENTATION
            async initializeGoogleSignIn() {
                try {
                    console.log('☁️ Initializing Google Sign-In...');
                    
                    // Load Google APIs
                    await this.loadGoogleAPI();
                    
                    const clientId = this.settings.apiKeys['google-client-id'] || document.getElementById('google-client-id')?.value;
                    
                    if (clientId) {
                        await gapi.load('auth2', async () => {
                            this.googleAuth = await gapi.auth2.init({
                                client_id: clientId,
                                scope: 'https://www.googleapis.com/auth/drive.file'
                            });
                            
                            // Check if user is already signed in
                            if (this.googleAuth.isSignedIn.get()) {
                                this.updateGoogleStatus(true);
                            }
                        });
                        
                        console.log('✅ Google Sign-In initialized');
                    } else {
                        console.log('⚠️ Google Client ID not configured');
                        this.updateGoogleStatus(false, 'Client ID not configured');
                    }
                } catch (error) {
                    console.error('❌ Google Sign-In initialization failed:', error);
                    this.updateGoogleStatus(false, 'Initialization failed');
                }
            }

            loadGoogleAPI() {
                return new Promise((resolve, reject) => {
                    if (window.gapi) {
                        resolve();
                        return;
                    }
                    
                    const script = document.createElement('script');
                    script.src = 'https://apis.google.com/js/api.js';
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            }

            async signInToGoogle() {
                try {
                    console.log('🔐 Attempting Google Sign-In...');
                    this.showLoading('Signing in to Google...');
                    
                    if (!this.googleAuth) {
                        await this.initializeGoogleSignIn();
                    }
                    
                    if (this.googleAuth) {
                        const authInstance = await this.googleAuth.signIn();
                        this.updateGoogleStatus(true);
                        this.showNotification('✅ Successfully signed in to Google!', 'success');
                        console.log('✅ Google Sign-In successful');
                    } else {
                        throw new Error('Google Auth not initialized');
                    }
                } catch (error) {
                    console.error('❌ Google Sign-In failed:', error);
                    this.showNotification('❌ Google Sign-In failed', 'error');
                    this.updateGoogleStatus(false, 'Sign-in failed');
                } finally {
                    this.hideLoading();
                }
            }

            async signOutFromGoogle() {
                try {
                    if (this.googleAuth && this.googleAuth.isSignedIn.get()) {
                        await this.googleAuth.signOut();
                        this.updateGoogleStatus(false);
                        this.showNotification('🚪 Signed out from Google', 'success');
                    }
                } catch (error) {
                    console.error('❌ Google Sign-Out failed:', error);
                    this.showNotification('❌ Sign-out failed', 'error');
                }
            }

            updateGoogleStatus(signedIn, message = '') {
                const statusElements = [
                    document.getElementById('google-status'),
                    document.getElementById('google-sign-in-status')
                ];
                
                statusElements.forEach(element => {
                    if (element) {
                        if (signedIn) {
                            const user = this.googleAuth?.currentUser?.get();
                            const email = user?.getBasicProfile()?.getEmail() || 'Unknown';
                            element.textContent = `✅ Signed in as ${email}`;
                            element.className = 'bg-green-500 text-white px-2 py-1 rounded-full text-xs';
                        } else {
                            element.textContent = message ? `❌ ${message}` : '❌ Not signed in';
                            element.className = 'bg-red-500 text-white px-2 py-1 rounded-full text-xs';
                        }
                    }
                });
            }

            async backupToGoogleDrive() {
                try {
                    if (!this.googleAuth || !this.googleAuth.isSignedIn.get()) {
                        this.showNotification('❌ Please sign in to Google first', 'error');
                        return;
                    }

                    this.showLoading('Backing up to Google Drive...');
                    
                    const data = {
                        items: this.items,
                        places: this.places,
                        garages: this.garages,
                        cabinets: this.cabinets,
                        shelves: this.shelves,
                        boxes: this.boxes,
                        settings: this.settings,
                        backupDate: new Date().toISOString(),
                        platform: 'Android',
                        version: '2.0'
                    };

                    // Load Google Drive API
                    await new Promise((resolve) => gapi.load('client', resolve));
                    await gapi.client.init({
                        apiKey: this.settings.apiKeys['google-api-key'],
                        clientId: this.settings.apiKeys['google-client-id'],
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
                        scope: 'https://www.googleapis.com/auth/drive.file'
                    });

                    const fileMetadata = {
                        name: `android_inventory_backup_${new Date().toISOString().split('T')[0]}.json`,
                        parents: ['appDataFolder']
                    };

                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(fileMetadata)], {type: 'application/json'}));
                    form.append('file', new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'}));

                    const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                        method: 'POST',
                        headers: new Headers({
                            'Authorization': `Bearer ${gapi.auth2.getAuthInstance().currentUser.get().getAuthResponse().access_token}`
                        }),
                        body: form
                    });

                    if (response.ok) {
                        this.showNotification('☁️ Backup saved to Google Drive successfully!', 'success');
                    } else {
                        throw new Error('Failed to upload to Google Drive');
                    }
                } catch (error) {
                    console.error('❌ Google Drive backup failed:', error);
                    this.showNotification('❌ Backup to Google Drive failed', 'error');
                } finally {
                    this.hideLoading();
                }
            }

            async restoreFromGoogleDrive() {
                try {
                    if (!this.googleAuth || !this.googleAuth.isSignedIn.get()) {
                        this.showNotification('❌ Please sign in to Google first', 'error');
                        return;
                    }

                    this.showLoading('Restoring from Google Drive...');
                    
                    // Implementation for restore from Google Drive
                    // This would list files and let user select which backup to restore
                    
                    this.showNotification('📥 Restore functionality coming soon!', 'warning');
                } catch (error) {
                    console.error('❌ Google Drive restore failed:', error);
                    this.showNotification('❌ Restore from Google Drive failed', 'error');
                } finally {
                    this.hideLoading();
                }
            }

            async loadData() {
                try {
                    this.items = [];
                    this.places = [];
                    this.garages = [];
                    this.cabinets = [];
                    this.shelves = [];
                    this.boxes = [];
                    this.history = [];
                    
                    if (window.inventoryAppData) {
                        this.items = window.inventoryAppData.items || [];
                        this.places = window.inventoryAppData.places || [];
                        this.garages = window.inventoryAppData.garages || [];
                        this.cabinets = window.inventoryAppData.cabinets || [];
                        this.shelves = window.inventoryAppData.shelves || [];
                        this.boxes = window.inventoryAppData.boxes || [];
                        this.history = window.inventoryAppData.history || [];
                    }
                    
                    // Load settings
                    if (window.inventoryAppSettings) {
                        this.settings = { ...this.settings, ...window.inventoryAppSettings };
                    }
                    
                    // Load custom options
                    this.customConditions = this.settings.customConditions || [];
                    this.customFunctionalities = this.settings.customFunctionalities || [];
                    
                    console.log('📊 Data loaded:', { 
                        items: this.items.length, 
                        places: this.places.length,
                        garages: this.garages.length,
                        cabinets: this.cabinets.length, 
                        shelves: this.shelves.length,
                        boxes: this.boxes.length,
                        history: this.history.length
                    });
                } catch (error) {
                    console.error('❌ Error loading data:', error);
                }
            }

            async saveData() {
                try {
                    window.inventoryAppData = {
                        items: this.items,
                        places: this.places,
                        garages: this.garages,
                        cabinets: this.cabinets,
                        shelves: this.shelves,
                        boxes: this.boxes,
                        history: this.history,
                        lastSaved: new Date().toISOString()
                    };
                    
                    // Auto-sync if enabled
                    if (this.settings.autoSyncSave && this.pairedDevices.length > 0) {
                        this.syncToComputer();
                    }
                    
                    console.log('💾 Data saved successfully');
                } catch (error) {
                    console.error('❌ Error saving data:', error);
                }
            }

            switchToTab(tabName) {
                console.log('📱 Switching to:', tabName);
                
                // Update tab buttons
                document.querySelectorAll('.android-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                const activeTab = document.querySelector(`.android-tab[data-tab="${tabName}"]`);
                if (activeTab) {
                    activeTab.classList.add('active');
                }
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.add('hidden');
                });
                const activeContent = document.getElementById(`${tabName}-tab`);
                if (activeContent) {
                    activeContent.classList.remove('hidden');
                }
                
                // Load tab-specific data
                switch (tabName) {
                    case 'dashboard':
                        this.updateDashboard();
                        this.updateCharts();
                        break;
                    case 'items':
                        this.updateItemForm();
                        break;
                    case 'locations':
                        this.renderLocationTree();
                        break;
                    case 'search':
                        this.updateSearchFilters();
                        break;
                    case 'overview':
                        this.refreshInventoryOverview();
                        break;
                    case 'images':
                        this.loadAllImages();
                        break;
                    case 'history':
                        this.renderHistory();
                        break;
                    case 'settings':
                        this.loadSettings();
                        break;
                    case 'sync':
                        this.updateSyncStatus();
                        break;
                }
            }

            initializeCharts() {
                console.log('📊 Initializing charts...');
                
                // Quantity Distribution Chart
                const quantityCtx = document.getElementById('quantityChart');
                if (quantityCtx) {
                    this.charts.quantity = new Chart(quantityCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Available', 'Low Stock', 'Out of Stock'],
                            datasets: [{
                                data: [0, 0, 0],
                                backgroundColor: ['#66bb6a', '#ffab40', '#ef5350'],
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        color: getComputedStyle(document.documentElement).getPropertyValue('--text-color'),
                                        font: { size: 10 },
                                        padding: 10
                                    }
                                }
                            }
                        }
                    });
                }

                // Category Chart
                const categoryCtx = document.getElementById('categoryChart');
                if (categoryCtx) {
                    this.charts.category = new Chart(categoryCtx, {
                        type: 'pie',
                        data: {
                            labels: [],
                            datasets: [{
                                data: [],
                                backgroundColor: ['#5D5CDE', '#66bb6a', '#ffab40', '#ef5350', '#ab47bc', '#26c6da'],
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        color: getComputedStyle(document.documentElement).getPropertyValue('--text-color'),
                                        font: { size: 10 },
                                        padding: 8
                                    }
                                }
                            }
                        }
                    });
                }

                console.log('✅ Charts initialized');
            }

            updateDashboard() {
                const totalItems = this.items.length;
                const totalValue = this.items.reduce((sum, item) => {
                    const minPrice = parseFloat(item.minPrice) || 0;
                    const maxPrice = parseFloat(item.maxPrice) || 0;
                    const avgPrice = minPrice && maxPrice ? (minPrice + maxPrice) / 2 : minPrice || maxPrice;
                    return sum + (avgPrice * (item.qty || 1));
                }, 0);
                const lowStockItems = this.items.filter(item => (item.qty || 0) <= 1).length;
                const totalLocations = this.places.length;

                document.getElementById('dashboard-total-items').textContent = totalItems;
                document.getElementById('dashboard-total-value').textContent = `$${totalValue.toFixed(2)}`;
                document.getElementById('dashboard-low-stock').textContent = lowStockItems;
                document.getElementById('dashboard-total-locations').textContent = totalLocations;
                document.getElementById('total-items').textContent = totalItems;
            }

            updateCharts() {
                // Update Quantity Distribution Chart
                if (this.charts.quantity) {
                    const available = this.items.filter(item => (item.qty || 0) > 1).length;
                    const lowStock = this.items.filter(item => (item.qty || 0) === 1).length;
                    const outOfStock = this.items.filter(item => (item.qty || 0) === 0).length;
                    
                    this.charts.quantity.data.datasets[0].data = [available, lowStock, outOfStock];
                    this.charts.quantity.update();
                }

                // Update Category Chart
                if (this.charts.category) {
                    const categories = {};
                    this.items.forEach(item => {
                        const category = item.category || 'Uncategorized';
                        categories[category] = (categories[category] || 0) + 1;
                    });

                    this.charts.category.data.labels = Object.keys(categories);
                    this.charts.category.data.datasets[0].data = Object.values(categories);
                    this.charts.category.update();
                }
            }

            updateUI() {
                this.updateDashboard();
                this.updateCharts();
                this.updateItemForm();
                this.renderLocationTree();
                console.log('📱 UI updated');
            }

            // ITEM MANAGEMENT WITH DUPLICATE DETECTION
            updateItemForm() {
                this.updateLocationDropdowns();
                this.updateConditionDropdown();
                this.updateFunctionalityDropdown();
            }

            newItem() {
                console.log('📱 Creating new item...');
                this.currentItemId = this.generateId();
                this.currentImages = [];
                
                const form = document.getElementById('item-form');
                if (form) {
                    form.reset();
                }
                
                document.getElementById('item-id').value = this.currentItemId;
                document.getElementById('item-qty').value = '1';
                this.renderItemImages();
                this.showNotification('📱 New item form ready', 'success');
            }

            async saveItem() {
                console.log('💾 Saving item...');
                try {
                    const itemData = this.getItemFormData();

                    // Check for duplicates before saving
                    const duplicate = this.checkForDuplicates(itemData);
                    if (duplicate && duplicate.id !== itemData.id) {
                        const location = this.getLocationString(duplicate);
                        this.showDuplicateWarning(itemData.name, itemData.model, location, () => {
                            this.saveItemForced(itemData);
                        });
                        return;
                    }

                    this.saveItemForced(itemData);
                } catch (error) {
                    console.error('❌ Error saving item:', error);
                    this.showNotification('❌ Failed to save item', 'error');
                }
            }

            saveItemForced(itemData) {
                const existingIndex = this.items.findIndex(item => item.id === itemData.id);
                const oldItem = existingIndex >= 0 ? { ...this.items[existingIndex] } : null;
                
                if (existingIndex >= 0) {
                    itemData.dateAdded = this.items[existingIndex].dateAdded;
                    this.items[existingIndex] = itemData;
                    
                    // Track changes for history
                    const changes = this.getItemChanges(oldItem, itemData);
                    if (Object.keys(changes).length > 0) {
                        this.addToHistory('update', itemData.id, itemData.name, 
                            `Updated: ${Object.keys(changes).join(', ')}`, oldItem);
                    }
                } else {
                    this.items.push(itemData);
                    this.addToHistory('create', itemData.id, itemData.name, 'Item created');
                }

                this.currentItemId = itemData.id;
                this.saveData();
                this.updateUI();
                this.showNotification('💾 Item saved successfully!', 'success');
            }

            checkForDuplicates(itemData) {
                return this.items.find(item => 
                    item.id !== itemData.id &&
                    ((item.name && itemData.name && item.name.toLowerCase() === itemData.name.toLowerCase()) ||
                     (item.model && itemData.model && item.model.toLowerCase() === itemData.model.toLowerCase()) ||
                     (item.sku && itemData.sku && item.sku.toLowerCase() === itemData.sku.toLowerCase()))
                );
            }

            showDuplicateWarning(name, model, location, onConfirm) {
                const modal = document.createElement('div');
                modal.className = 'android-modal';
                modal.innerHTML = `
                    <div class="android-modal-content">
                        <div class="text-center mb-4">
                            <div class="text-4xl mb-3">⚠️</div>
                            <h3 class="text-lg font-bold mb-3">Duplicate Item Detected</h3>
                            <p class="text-sm mb-2">This item already exists:</p>
                            <p class="font-bold text-red-600">${name || model || 'Similar item'}</p>
                            <p class="text-xs opacity-75 mt-2">📍 Location: ${location}</p>
                        </div>
                        <div class="flex justify-end space-x-3">
                            <button class="android-btn android-btn-secondary duplicate-cancel text-xs">❌ Cancel</button>
                            <button class="android-btn android-btn-warning duplicate-save text-xs">⚠️ Save Anyway</button>
                        </div>
                    </div>
                `;
                
                const cancelBtn = modal.querySelector('.duplicate-cancel');
                const saveBtn = modal.querySelector('.duplicate-save');
                
                this.addAndroidTouchEvents(cancelBtn, () => modal.remove());
                this.addAndroidTouchEvents(saveBtn, () => {
                    modal.remove();
                    onConfirm();
                });
                
                document.body.appendChild(modal);
            }

            // HISTORY TRACKING SYSTEM
            addToHistory(type, itemId, itemName, changes, oldValues = {}) {
                const historyEntry = {
                    id: this.generateId(),
                    type: type, // 'create', 'update', 'delete', 'location', 'quantity'
                    itemId: itemId,
                    itemName: itemName,
                    changes: changes,
                    oldValues: oldValues,
                    timestamp: new Date().toISOString(),
                    user: 'Android User'
                };
                
                this.history.unshift(historyEntry); // Add to beginning
                
                // Keep only last 1000 entries to prevent memory issues
                if (this.history.length > 1000) {
                    this.history = this.history.slice(0, 1000);
                }
                
                this.saveData();
                console.log('📚 Added to history:', historyEntry);
            }

            renderHistory() {
                const container = document.getElementById('history-list');
                if (!container) return;

                let filteredHistory = [...this.history];
                
                // Apply filters
                const searchTerm = document.getElementById('history-search')?.value.toLowerCase() || '';
                const typeFilter = document.getElementById('history-type-filter')?.value || '';
                const dateFilter = document.getElementById('history-date-filter')?.value || '';

                if (searchTerm) {
                    filteredHistory = filteredHistory.filter(entry => 
                        (entry.itemName || '').toLowerCase().includes(searchTerm) ||
                        (entry.changes || '').toLowerCase().includes(searchTerm)
                    );
                }

                if (typeFilter) {
                    filteredHistory = filteredHistory.filter(entry => entry.type === typeFilter);
                }

                if (dateFilter) {
                    const filterDate = new Date(dateFilter).toDateString();
                    filteredHistory = filteredHistory.filter(entry => 
                        new Date(entry.timestamp).toDateString() === filterDate
                    );
                }

                container.innerHTML = '';

                if (filteredHistory.length === 0) {
                    container.innerHTML = '<div class="android-list-item"><div class="text-center opacity-75">📚 No history entries found</div></div>';
                    return;
                }

                filteredHistory.forEach(entry => {
                    const div = document.createElement('div');
                    div.className = 'android-list-item';
                    
                    const timestamp = new Date(entry.timestamp).toLocaleString();
                    const typeIcon = this.getHistoryIcon(entry.type);
                    
                    div.innerHTML = `
                        <div class="flex-1">
                            <div class="flex items-center gap-1">
                                <span class="text-sm">${typeIcon}</span>
                                <div class="font-bold text-sm">${entry.itemName || 'Unknown Item'}</div>
                            </div>
                            <div class="text-xs opacity-75 mt-1">${entry.changes}</div>
                            <div class="text-xs opacity-50">${timestamp}</div>
                        </div>
                        <div class="ml-2">
                            <button onclick="inventoryManager.viewHistoryDetails('${entry.id}')" class="android-btn android-btn-secondary text-xs">Details</button>
                        </div>
                    `;
                    
                    container.appendChild(div);
                });
            }

            getHistoryIcon(type) {
                switch (type) {
                    case 'create': return '➕';
                    case 'update': return '✏️';
                    case 'delete': return '🗑️';
                    case 'location': return '📍';
                    case 'quantity': return '🔢';
                    default: return '📝';
                }
            }

            filterHistory() {
                this.renderHistory();
            }

            clearHistory() {
                this.showConfirmDialog('📚 Clear all history entries? This cannot be undone.', () => {
                    this.history = [];
                    this.saveData();
                    this.renderHistory();
                    this.showNotification('📚 History cleared successfully!', 'success');
                });
            }

            exportHistory() {
                if (this.history.length === 0) {
                    this.showNotification('📚 No history to export', 'warning');
                    return;
                }

                const data = this.history.map(entry => ({
                    'Date/Time': new Date(entry.timestamp).toLocaleString(),
                    'Change Type': entry.type,
                    'Item Name': entry.itemName || '',
                    'Changes': entry.changes || '',
                    'User': entry.user || 'Android User'
                }));

                const csvContent = this.convertToCSV(data);
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `inventory_history_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showNotification('📚 History exported successfully!', 'success');
            }

            viewHistoryDetails(historyId) {
                const entry = this.history.find(h => h.id === historyId);
                if (!entry) return;

                const modal = document.createElement('div');
                modal.className = 'android-modal';
                modal.innerHTML = `
                    <div class="android-modal-content">
                        <h3 class="text-lg font-bold mb-3">${this.getHistoryIcon(entry.type)} History Details</h3>
                        <div class="space-y-2 text-sm">
                            <div><strong>Item:</strong> ${entry.itemName || 'Unknown'}</div>
                            <div><strong>Change Type:</strong> ${entry.type}</div>
                            <div><strong>Changes:</strong> ${entry.changes}</div>
                            <div><strong>Timestamp:</strong> ${new Date(entry.timestamp).toLocaleString()}</div>
                            <div><strong>User:</strong> ${entry.user || 'Android User'}</div>
                            ${entry.oldValues && Object.keys(entry.oldValues).length > 0 ? 
                                `<div><strong>Old Values:</strong> ${JSON.stringify(entry.oldValues, null, 2)}</div>` : ''
                            }
                        </div>
                        <div class="flex justify-end mt-4">
                            <button class="android-btn android-btn-primary close-modal text-xs">Close</button>
                        </div>
                    </div>
                `;
                
                const closeBtn = modal.querySelector('.close-modal');
                this.addAndroidTouchEvents(closeBtn, () => modal.remove());
                
                document.body.appendChild(modal);
            }

            // PRIORITY SYSTEM FOR OCR/AI FALLBACKS
            setupPriorityLists() {
                this.renderOCRPriorityList();
                this.renderAIPriorityList();
            }

            renderOCRPriorityList() {
                const container = document.getElementById('ocr-priority-list');
                if (!container) return;

                const ocrMethods = {
                    'tesseract': '📄 Tesseract.js (Free)',
                    'roboflow': '🤖 Roboflow OCR',
                    'ocrspace': '☁️ OCR Space',
                    'optiic': '⚡ Optiic.dev',
                    'google-vision': '🔍 Google Vision'
                };

                container.innerHTML = '';
                this.settings.ocrPriority.forEach((method, index) => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between p-2 bg-gray-100 dark:bg-gray-700 rounded-lg';
                    div.innerHTML = `
                        <div class="flex items-center gap-1">
                            <span class="font-bold text-xs">${index + 1}.</span>
                            <span class="text-xs">${ocrMethods[method] || method}</span>
                        </div>
                        <div class="flex gap-1">
                            <button onclick="inventoryManager.moveOCRPriority('${method}', 'up')" class="android-btn android-btn-secondary text-xs py-1 px-2" ${index === 0 ? 'disabled' : ''}>↑</button>
                            <button onclick="inventoryManager.moveOCRPriority('${method}', 'down')" class="android-btn android-btn-secondary text-xs py-1 px-2" ${index === this.settings.ocrPriority.length - 1 ? 'disabled' : ''}>↓</button>
                        </div>
                    `;
                    container.appendChild(div);
                });
            }

            renderAIPriorityList() {
                const container = document.getElementById('ai-priority-list');
                if (!container) return;

                const aiMethods = {
                    'gemini': '🔮 Google Gemini',
                    'openai': '🤖 OpenAI GPT',
                    'claude': '🎭 Anthropic Claude',
                    'offline': '📱 Smart Offline'
                };

                container.innerHTML = '';
                this.settings.aiPriority.forEach((method, index) => {
                    const div = document.createElement('div');
                    div.className = 'flex items-center justify-between p-2 bg-gray-100 dark:bg-gray-700 rounded-lg';
                    div.innerHTML = `
                        <div class="flex items-center gap-1">
                            <span class="font-bold text-xs">${index + 1}.</span>
                            <span class="text-xs">${aiMethods[method] || method}</span>
                        </div>
                        <div class="flex gap-1">
                            <button onclick="inventoryManager.moveAIPriority('${method}', 'up')" class="android-btn android-btn-secondary text-xs py-1 px-2" ${index === 0 ? 'disabled' : ''}>↑</button>
                            <button onclick="inventoryManager.moveAIPriority('${method}', 'down')" class="android-btn android-btn-secondary text-xs py-1 px-2" ${index === this.settings.aiPriority.length - 1 ? 'disabled' : ''}>↓</button>
                        </div>
                    `;
                    container.appendChild(div);
                });
            }

            moveOCRPriority(method, direction) {
                const currentIndex = this.settings.ocrPriority.indexOf(method);
                if (currentIndex === -1) return;

                const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
                if (newIndex < 0 || newIndex >= this.settings.ocrPriority.length) return;

                // Swap positions
                [this.settings.ocrPriority[currentIndex], this.settings.ocrPriority[newIndex]] = 
                [this.settings.ocrPriority[newIndex], this.settings.ocrPriority[currentIndex]];

                this.renderOCRPriorityList();
                this.saveSettings();
                this.showNotification('📄 OCR priority updated', 'success');
            }

            moveAIPriority(method, direction) {
                const currentIndex = this.settings.aiPriority.indexOf(method);
                if (currentIndex === -1) return;

                const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
                if (newIndex < 0 || newIndex >= this.settings.aiPriority.length) return;

                // Swap positions
                [this.settings.aiPriority[currentIndex], this.settings.aiPriority[newIndex]] = 
                [this.settings.aiPriority[newIndex], this.settings.aiPriority[currentIndex]];

                this.renderAIPriorityList();
                this.saveSettings();
                this.showNotification('🤖 AI priority updated', 'success');
            }

            resetOCRPriority() {
                this.settings.ocrPriority = ['tesseract', 'roboflow', 'ocrspace', 'optiic', 'google-vision'];
                this.renderOCRPriorityList();
                this.saveSettings();
                this.showNotification('📄 OCR priority reset to default', 'success');
            }

            resetAIPriority() {
                this.settings.aiPriority = ['gemini', 'openai', 'offline'];
                this.renderAIPriorityList();
                this.saveSettings();
                this.showNotification('🤖 AI priority reset to default', 'success');
            }

            // ENHANCED FALLBACK OCR WITH PRIORITY SYSTEM
            async processOCR() {
                if (this.currentImages.length === 0) {
                    this.showNotification('❌ No images available for OCR', 'error');
                    return;
                }

                this.showLoading('📱 Processing OCR with fallback...');

                try {
                    const image = this.currentImages[this.currentImages.length - 1];
                    let text = '';
                    let successfulMethod = null;
                    
                    // Try each OCR method in priority order
                    for (const method of this.settings.ocrPriority) {
                        try {
                            console.log(`🔄 Trying OCR method: ${method}`);
                            
                            switch (method) {
                                case 'roboflow':
                                    text = await this.processRoboflowOCR(image);
                                    break;
                                case 'ocrspace':
                                    text = await this.processOCRSpaceOCR(image);
                                    break;
                                case 'optiic':
                                    text = await this.processOptiicOCR(image);
                                    break;
                                case 'google-vision':
                                    text = await this.processGoogleVisionOCR(image);
                                    break;
                                case 'tesseract':
                                default:
                                    text = await this.processTesseractOCR(image);
                                    break;
                            }
                            
                            if (text && text.trim().length > 0) {
                                successfulMethod = method;
                                break; // Success! Stop trying other methods
                            }
                        } catch (error) {
                            console.log(`❌ OCR method ${method} failed:`, error.message);
                            continue; // Try next method
                        }
                    }
                    
                    if (text && text.trim().length > 0) {
                        this.fillFormFromOCR(text);
                        this.showNotification(`📱 OCR completed with ${successfulMethod}!`, 'success');
                    } else {
                        throw new Error('All OCR methods failed');
                    }
                } catch (error) {
                    console.error('❌ All OCR methods failed:', error);
                    this.showNotification('❌ All OCR methods failed', 'error');
                } finally {
                    this.hideLoading();
                }
            }

            // ENHANCED FALLBACK AI WITH PRIORITY SYSTEM
            async processAI() {
                if (this.currentImages.length === 0) {
                    this.showNotification('❌ No images available for AI processing', 'error');
                    return;
                }

                this.showLoading('🤖 Processing AI with fallback...');

                try {
                    const image = this.currentImages[this.currentImages.length - 1];
                    let description = '';
                    let successfulMethod = null;
                    
                    // Try each AI method in priority order
                    for (const method of this.settings.aiPriority) {
                        try {
                            console.log(`🔄 Trying AI method: ${method}`);
                            
                            switch (method) {
                                case 'gemini':
                                    description = await this.processGeminiAI(image);
                                    break;
                                case 'openai':
                                    description = await this.processOpenAI(image);
                                    break;
                                case 'claude':
                                    description = await this.processClaudeAI(image);
                                    break;
                                case 'offline':
                                default:
                                    description = await this.processOfflineAI(image);
                                    break;
                            }
                            
                            if (description && description.trim().length > 0) {
                                successfulMethod = method;
                                break; // Success! Stop trying other methods
                            }
                        } catch (error) {
                            console.log(`❌ AI method ${method} failed:`, error.message);
                            continue; // Try next method
                        }
                    }
                    
                    if (description && description.trim().length > 0) {
                        this.fillFormFromAI(description);
                        this.showNotification(`🤖 AI processing completed with ${successfulMethod}!`, 'success');
                    } else {
                        throw new Error('All AI methods failed');
                    }
                } catch (error) {
                    console.error('❌ All AI methods failed:', error);
                    this.showNotification('❌ All AI methods failed', 'error');
                } finally {
                    this.hideLoading();
                }
            }

            // CUSTOMIZABLE CONDITIONS AND FUNCTIONALITY
            addCustomCondition() {
                this.showPromptDialog('➕ Enter new condition:', (condition) => {
                    if (condition && condition.trim()) {
                        const trimmedCondition = condition.trim();
                        if (!this.customConditions.includes(trimmedCondition)) {
                            this.customConditions.push(trimmedCondition);
                            this.updateConditionDropdown();
                            document.getElementById('item-condition').value = trimmedCondition;
                            this.saveSettings();
                            this.showNotification(`➕ Added condition: ${trimmedCondition}`, 'success');
                        } else {
                            this.showNotification('⚠️ Condition already exists', 'warning');
                        }
                    }
                });
            }

            addCustomFunctionality() {
                this.showPromptDialog('➕ Enter new functionality:', (functionality) => {
                    if (functionality && functionality.trim()) {
                        const trimmedFunctionality = functionality.trim();
                        if (!this.customFunctionalities.includes(trimmedFunctionality)) {
                            this.customFunctionalities.push(trimmedFunctionality);
                            this.updateFunctionalityDropdown();
                            document.getElementById('item-functionality').value = trimmedFunctionality;
                            this.saveSettings();
                            this.showNotification(`➕ Added functionality: ${trimmedFunctionality}`, 'success');
                        } else {
                            this.showNotification('⚠️ Functionality already exists', 'warning');
                        }
                    }
                });
            }

            updateConditionDropdown() {
                const select = document.getElementById('item-condition');
                if (!select) return;

                const currentValue = select.value;
                const defaultOptions = ['New', 'Like New', 'Good', 'Fair', 'Poor', 'Refurbished', 'Used', 'For Parts'];
                
                select.innerHTML = '<option value="">Select condition...</option>';
                
                [...defaultOptions, ...this.customConditions].forEach(condition => {
                    const option = document.createElement('option');
                    option.value = condition;
                    option.textContent = condition;
                    select.appendChild(option);
                });
                
                select.value = currentValue;
            }

            updateFunctionalityDropdown() {
                const select = document.getElementById('item-functionality');
                if (!select) return;

                const currentValue = select.value;
                const defaultOptions = ['Fully Functional', 'Mostly Functional', 'Partially Functional', 'Not Functional', 'Unknown', 'Needs Testing', 'Needs Repair'];
                
                select.innerHTML = '<option value="">Select functionality...</option>';
                
                [...defaultOptions, ...this.customFunctionalities].forEach(functionality => {
                    const option = document.createElement('option');
                    option.value = functionality;
                    option.textContent = functionality;
                    select.appendChild(option);
                });
                
                select.value = currentValue;
            }

            // ENHANCED AUTO-SAVE WITH VISUAL FEEDBACK
            async saveItemSilently() {
                console.log('🔄 Auto-saving item...');
                
                // Show auto-save indicator
                const indicator = document.getElementById('auto-save-indicator');
                if (indicator) {
                    indicator.classList.add('show');
                    setTimeout(() => indicator.classList.remove('show'), 2000);
                }
                
                try {
                    const itemData = this.getItemFormData();
                    const existingIndex = this.items.findIndex(item => item.id === itemData.id);
                    const oldItem = existingIndex >= 0 ? { ...this.items[existingIndex] } : null;
                    
                    if (existingIndex >= 0) {
                        itemData.dateAdded = this.items[existingIndex].dateAdded;
                        this.items[existingIndex] = itemData;
                        
                        // Track changes for history
                        if (oldItem) {
                            const changes = this.getItemChanges(oldItem, itemData);
                            if (Object.keys(changes).length > 0) {
                                this.addToHistory('update', itemData.id, itemData.name, 
                                    `Updated: ${Object.keys(changes).join(', ')}`, oldItem);
                            }
                        }
                    } else {
                        this.items.push(itemData);
                        this.addToHistory('create', itemData.id, itemData.name, 'Item created');
                    }

                    this.currentItemId = itemData.id;
                    await this.saveData();
                    console.log('✅ Auto-save completed');
                } catch (error) {
                    console.error('❌ Error auto-saving item:', error);
                }
            }

            getItemFormData() {
                // Ensure the form has a stable id value so autosave doesn't generate multiple different items
                const idEl = document.getElementById('item-id');
                if (idEl && !idEl.value) {
                    idEl.value = this.generateId();
                }
                return {
                    id: document.getElementById('item-id').value || this.generateId(),
                    name: document.getElementById('item-name').value,
                    sku: document.getElementById('item-sku').value,
                    model: document.getElementById('item-model').value,
                    condition: document.getElementById('item-condition').value,
                    functionality: document.getElementById('item-functionality').value,
                    description: document.getElementById('item-description').value,
                    qty: parseInt(document.getElementById('item-qty').value) || 1,
                    placeId: document.getElementById('item-place').value,
                    garageId: document.getElementById('item-garage').value,
                    cabinetId: document.getElementById('item-cabinet').value,
                    shelfId: document.getElementById('item-shelf').value,
                    boxId: document.getElementById('item-box').value,
                    weblink: document.getElementById('item-weblink').value,
                    minPrice: document.getElementById('item-min-price').value,
                    maxPrice: document.getElementById('item-max-price').value,
                    weight: document.getElementById('item-weight').value,
                    sizeCategory: document.getElementById('item-size').value,
                    dimensions: document.getElementById('item-dimensions').value,
                    dateAdded: new Date().toISOString(),
                    dateModified: new Date().toISOString(),
                    images: this.currentImages
                };
            }

            getItemChanges(oldItem, newItem) {
                const changes = {};
                const fields = ['name', 'model', 'condition', 'functionality', 'qty', 'placeId', 'garageId', 'cabinetId', 'shelfId', 'boxId'];
                
                fields.forEach(field => {
                    if (oldItem[field] !== newItem[field]) {
                        changes[field] = { from: oldItem[field], to: newItem[field] };
                    }
                });
                
                return changes;
            }

            previousItem() {
                if (this.items.length === 0) return;
                
                const currentIndex = this.currentItemId ? 
                    this.items.findIndex(item => item.id === this.currentItemId) : -1;
                const prevIndex = currentIndex <= 0 ? this.items.length - 1 : currentIndex - 1;
                
                this.loadItemToForm(this.items[prevIndex]);
            }

            nextItem() {
                if (this.items.length === 0) return;
                
                const currentIndex = this.currentItemId ? 
                    this.items.findIndex(item => item.id === this.currentItemId) : -1;
                const nextIndex = currentIndex >= this.items.length - 1 ? 0 : currentIndex + 1;
                
                this.loadItemToForm(this.items[nextIndex]);
            }

            loadItemToForm(item) {
                this.currentItemId = item.id;
                this.currentImages = item.images || [];
                
                document.getElementById('item-id').value = item.id;
                document.getElementById('item-name').value = item.name || '';
                document.getElementById('item-sku').value = item.sku || '';
                document.getElementById('item-model').value = item.model || '';
                document.getElementById('item-condition').value = item.condition || '';
                document.getElementById('item-functionality').value = item.functionality || '';
                document.getElementById('item-description').value = item.description || '';
                document.getElementById('item-qty').value = item.qty || 1;
                document.getElementById('item-weblink').value = item.weblink || '';
                document.getElementById('item-min-price').value = item.minPrice || '';
                document.getElementById('item-max-price').value = item.maxPrice || '';
                document.getElementById('item-weight').value = item.weight || '';
                document.getElementById('item-size').value = item.sizeCategory || '';
                document.getElementById('item-dimensions').value = item.dimensions || '';
                
                document.getElementById('item-place').value = item.placeId || '';
                this.updateGarageDropdown();
                document.getElementById('item-garage').value = item.garageId || '';
                this.updateCabinetDropdown();
                document.getElementById('item-cabinet').value = item.cabinetId || '';
                this.updateShelfDropdown();
                document.getElementById('item-shelf').value = item.shelfId || '';
                this.updateBoxDropdown();
                document.getElementById('item-box').value = item.boxId || '';
                
                this.renderItemImages();
            }

            // ENHANCED SEARCH
            updateSearchFilters() {
                const locationSelect = document.getElementById('search-location');
                if (!locationSelect) return;

                locationSelect.innerHTML = '<option value="">All Locations</option>';
                
                this.places.forEach(place => {
                    const option = document.createElement('option');
                    option.value = place.id;
                    option.textContent = place.name;
                    locationSelect.appendChild(option);
                });
            }

            sortTable(column) {
                console.log('📱 Sorting by:', column);
                
                if (this.sortOrder[column] === 'asc') {
                    this.sortOrder[column] = 'desc';
                } else {
                    this.sortOrder[column] = 'asc';
                }

                // Update visual indicators
                ['id', 'name', 'model', 'location', 'created', 'modified'].forEach(col => {
                    const header = document.getElementById(`sort-header-${col}`);
                    if (header) {
                        header.classList.remove('sorted-asc', 'sorted-desc');
                        if (col === column) {
                            header.classList.add(this.sortOrder[column] === 'asc' ? 'sorted-asc' : 'sorted-desc');
                        }
                    }
                });

                this.searchItems();
            }

            searchItems() {
                console.log('🔍 Searching items...');
                
                const searchTerm = document.getElementById('search-input').value.toLowerCase();
                const categoryFilter = document.getElementById('search-category').value;
                const locationFilter = document.getElementById('search-location').value;
                const dateFrom = document.getElementById('search-date-from').value;
                const dateTo = document.getElementById('search-date-to').value;
                
                let filteredItems = this.items.filter(item => {
                    const matchesSearch = !searchTerm || 
                        (item.name && item.name.toLowerCase().includes(searchTerm)) ||
                        (item.model && item.model.toLowerCase().includes(searchTerm)) ||
                        (item.description && item.description.toLowerCase().includes(searchTerm)) ||
                        (item.sku && item.sku.toLowerCase().includes(searchTerm));

                    const matchesCategory = !categoryFilter || item.category === categoryFilter;
                    const matchesLocation = !locationFilter || item.placeId === locationFilter;
                    
                    let matchesDate = true;
                    if (dateFrom || dateTo) {
                        const itemDate = new Date(item.dateAdded);
                        if (dateFrom && itemDate < new Date(dateFrom)) matchesDate = false;
                        if (dateTo && itemDate > new Date(dateTo + 'T23:59:59')) matchesDate = false;
                    }

                    return matchesSearch && matchesCategory && matchesLocation && matchesDate;
                });

                // Apply sorting
                const currentSort = Object.keys(this.sortOrder).find(key => this.sortOrder[key]);
                if (currentSort) {
                    filteredItems.sort((a, b) => {
                        let comparison = 0;
                        
                        switch (currentSort) {
                            case 'name':
                                comparison = (a.name || '').localeCompare(b.name || '');
                                break;
                            case 'model':
                                comparison = (a.model || '').localeCompare(b.model || '');
                                break;
                            case 'created':
                                comparison = new Date(a.dateAdded || 0) - new Date(b.dateAdded || 0);
                                break;
                            case 'modified':
                                comparison = new Date(a.dateModified || 0) - new Date(b.dateModified || 0);
                                break;
                            case 'location':
                                comparison = this.getLocationString(a).localeCompare(this.getLocationString(b));
                                break;
                            default:
                                comparison = (a.id || '').localeCompare(b.id || '');
                        }
                        
                        return this.sortOrder[currentSort] === 'desc' ? -comparison : comparison;
                    });
                }

                this.renderSearchResults(filteredItems);
            }

            renderSearchResults(items) {
                const container = document.getElementById('search-results');
                if (!container) return;

                container.innerHTML = '';

                if (items.length === 0) {
                    container.innerHTML = '<div class="android-list-item"><div class="text-center opacity-75">🔍 No items found</div></div>';
                    return;
                }

                items.forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'android-list-item';
                    
                    const dateCreated = item.dateAdded ? new Date(item.dateAdded).toLocaleDateString() : 'N/A';
                    const dateModified = item.dateModified ? new Date(item.dateModified).toLocaleDateString() : 'N/A';
                    
                    div.innerHTML = `
                        <div class="flex-1">
                            <div class="font-bold text-sm">${item.name || 'Unnamed Item'}</div>
                            <div class="text-xs opacity-75">
                                ID: ${item.id} | Model: ${item.model || 'N/A'} | Location: ${this.getLocationString(item)}
                            </div>
                            <div class="text-xs opacity-50">
                                Created: ${dateCreated} | Modified: ${dateModified}
                            </div>
                        </div>
                        <div class="ml-2">
                            <button onclick="inventoryManager.viewItemById('${item.id}')" class="android-btn android-btn-primary text-xs">View</button>
                        </div>
                    `;
                    
                    container.appendChild(div);
                });
            }

            clearSearch() {
                document.getElementById('search-input').value = '';
                document.getElementById('search-category').value = '';
                document.getElementById('search-location').value = '';
                document.getElementById('search-date-from').value = '';
                document.getElementById('search-date-to').value = '';
                
                // Clear sort indicators
                Object.keys(this.sortOrder).forEach(key => {
                    this.sortOrder[key] = null;
                    const header = document.getElementById(`sort-header-${key}`);
                    if (header) {
                        header.classList.remove('sorted-asc', 'sorted-desc');
                    }
                });
                
                const container = document.getElementById('search-results');
                if (container) {
                    container.innerHTML = '<div class="android-list-item"><div class="text-center opacity-75">🔍 Use search to find items</div></div>';
                }
            }

            viewItemById(itemId) {
                const item = this.items.find(i => i.id === itemId);
                if (item) {
                    this.loadItemToForm(item);
                    this.switchToTab('items');
                } else {
                    this.showNotification('❌ Item not found', 'error');
                }
            }

            // IMAGE MANAGEMENT WITH ENHANCED VIEWING - FIXED
            uploadImages() {
                document.getElementById('hidden-file-input').click();
            }

            openCamera() {
                document.getElementById('hidden-camera-input').click();
            }

            async handleFileUpload(event) {
                const files = Array.from(event.target.files);
                console.log(`📱 Processing ${files.length} files...`);
                
                for (const file of files) {
                    if (file.type.startsWith('image/')) {
                        const imageData = await this.fileToBase64(file);
                        this.currentImages.push({
                            id: this.generateId(),
                            data: imageData,
                            name: file.name,
                            type: file.type,
                            timestamp: new Date().toISOString()
                        });
                    }
                }
                
                this.renderItemImages();
                event.target.value = '';
                this.showNotification(`📱 ${files.length} images uploaded!`, 'success');
            }

            renderItemImages() {
                const container = document.getElementById('item-images');
                if (!container) return;

                container.innerHTML = '';

                this.currentImages.forEach(image => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'relative inline-block';
                    wrapper.style.marginRight = '6px';

                    const img = document.createElement('img');
                    img.src = image.data;
                    img.className = 'w-12 h-12 object-cover rounded-lg border cursor-pointer';
                    img.style.borderColor = 'var(--border-color)';
                    this.addAndroidTouchEvents(img, () => this.viewImageFull(image));

                    // Remove button (small 'x' at top-right)
                    const removeBtn = document.createElement('button');
                    removeBtn.className = 'android-btn android-btn-danger text-xs';
                    removeBtn.style.position = 'absolute';
                    removeBtn.style.top = '-6px';
                    removeBtn.style.right = '-6px';
                    removeBtn.style.padding = '4px';
                    removeBtn.style.minHeight = '22px';
                    removeBtn.style.borderRadius = '12px';
                    removeBtn.textContent = '✖';
                    removeBtn.title = 'Remove image';
                    removeBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.removeImage(image.id);
                    });

                    wrapper.appendChild(img);
                    wrapper.appendChild(removeBtn);
                    container.appendChild(wrapper);
                });
            }

            viewImageFull(image) {
                const modal = document.createElement('div');
                modal.className = 'image-modal';
                modal.innerHTML = `
                    <img src="${image.data}" alt="${image.name}">
                `;
                
                modal.addEventListener('click', () => {
                    modal.remove();
                });
                
                document.body.appendChild(modal);
            }

            loadAllImages() {
                const container = document.getElementById('all-images-grid');
                if (!container) return;

                container.innerHTML = '';

                const allImages = [];
                this.items.forEach(item => {
                    if (item.images && item.images.length > 0) {
                        item.images.forEach(image => {
                            allImages.push({
                                ...image,
                                itemId: item.id,
                                itemName: item.name
                            });
                        });
                    }
                });

                if (allImages.length === 0) {
                    container.innerHTML = '<div class="android-list-item col-span-full"><div class="text-center opacity-75">📷 No images available</div></div>';
                    return;
                }

                allImages.forEach(image => {
                    const div = document.createElement('div');
                    div.className = 'relative';
                    div.innerHTML = `
                        <img src="${image.data}" class="w-full h-24 object-cover rounded-lg border cursor-pointer" style="border-color: var(--border-color);">
                        <div class="absolute bottom-0 left-0 right-0 bg-black bg-opacity-75 text-white text-xs p-1 rounded-b-lg">
                            ${image.itemName || 'Unnamed Item'}
                        </div>
                    `;
                    
                    // Add click event for thumbnail
                    const imgElement = div.querySelector('img');
                    this.addAndroidTouchEvents(imgElement, () => {
                        this.viewItemById(image.itemId);
                    });
                    
                    container.appendChild(div);
                });
            }

            // OCR PROCESSING WITH MULTIPLE APIS
            async processTesseractOCR(image) {
                const { data: { text } } = await Tesseract.recognize(image.data, 'eng');
                return text;
            }

            async processRoboflowOCR(image) {
                const apiKey = this.settings.apiKeys['roboflow-api-key'] || document.getElementById('roboflow-api-key')?.value;
                if (!apiKey) {
                    throw new Error('Roboflow API key not configured');
                }
                
                // Convert base64 to blob
                const response = await fetch(image.data);
                const blob = await response.blob();
                
                const formData = new FormData();
                formData.append('file', blob);
                
                const ocrResponse = await fetch(`https://api.roboflow.com/ocr?api_key=${apiKey}`, {
                    method: 'POST',
                    body: formData
                });
                
                if (!ocrResponse.ok) {
                    throw new Error('Roboflow OCR API request failed');
                }
                
                const result = await ocrResponse.json();
                return result.text || '';
            }

            async processOCRSpaceOCR(image) {
                const apiKey = this.settings.apiKeys['ocrspace-api-key'] || document.getElementById('ocrspace-api-key')?.value;
                if (!apiKey) {
                    throw new Error('OCR Space API key not configured');
                }
                
                const formData = new FormData();
                formData.append('base64Image', image.data);
                formData.append('language', 'eng');
                
                const response = await fetch('https://api.ocr.space/parse/image', {
                    method: 'POST',
                    headers: {
                        'apikey': apiKey
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error('OCR Space API request failed');
                }
                
                const result = await response.json();
                return result.ParsedResults?.[0]?.ParsedText || '';
            }

            async processOptiicOCR(image) {
                const apiKey = this.settings.apiKeys['optiic-api-key'] || document.getElementById('optiic-api-key')?.value;
                if (!apiKey) {
                    throw new Error('Optiic.dev API key not configured');
                }
                
                const response = await fetch('https://api.optiic.dev/ocr', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        image: image.data
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Optiic.dev API request failed');
                }
                
                const result = await response.json();
                return result.text || '';
            }

            async processGoogleVisionOCR(image) {
                const apiKey = this.settings.apiKeys['google-vision-key'] || document.getElementById('google-vision-key')?.value;
                if (!apiKey) {
                    throw new Error('Google Vision API key not configured');
                }
                
                // Simulate Google Vision OCR (real implementation would use Google Vision API)
                await new Promise(resolve => setTimeout(resolve, 2000));
                throw new Error('Google Vision OCR not fully implemented - using fallback');
            }

            fillFormFromOCR(text) {
                const lines = text.split('\n').filter(line => line.trim());
                
                if (lines.length > 0 && !document.getElementById('item-name').value) {
                    document.getElementById('item-name').value = lines[0].trim();
                }

                const modelMatch = text.match(/model[:\s]+([^\n\r]+)/i);
                if (modelMatch && !document.getElementById('item-model').value) {
                    document.getElementById('item-model').value = modelMatch[1].trim();
                }

                if (!document.getElementById('item-description').value) {
                    document.getElementById('item-description').value = text.trim();
                }
            }

            // AI PROCESSING WITH GEMINI AND FALLBACKS
            async processGeminiAI(image) {
                const apiKey = this.settings.apiKeys['gemini-key'] || document.getElementById('gemini-key')?.value;
                if (!apiKey) {
                    throw new Error('Gemini API key not configured');
                }
                
                try {
                    // Convert base64 to blob for Gemini
                    const base64Data = image.data.split(',')[1];
                    
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro-vision:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [
                                    {
                                        text: "Analyze this image and provide a detailed description for an inventory item. Include the item name, model if visible, estimated size category (Small/Medium/Large/X-Large), and any other relevant details. Format your response as: Name: [name], Model: [model], Size: [size], Description: [detailed description]"
                                    },
                                    {
                                        inline_data: {
                                            mime_type: image.type,
                                            data: base64Data
                                        }
                                    }
                                ]
                            }]
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Gemini API error: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    return result.candidates?.[0]?.content?.parts?.[0]?.text || '';
                } catch (error) {
                    console.error('❌ Gemini AI failed:', error);
                    throw error;
                }
            }

            async processOpenAI(image) {
                const apiKey = this.settings.apiKeys['openai-key'] || document.getElementById('openai-key')?.value;
                if (!apiKey) {
                    throw new Error('OpenAI API key not configured');
                }
                
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'gpt-4-vision-preview',
                        messages: [{
                            role: 'user',
                            content: [
                                {
                                    type: 'text',
                                    text: 'Analyze this image and provide a detailed description for an inventory item. Include the item name, model if visible, estimated size category (Small/Medium/Large/X-Large), and any other relevant details.'
                                },
                                {
                                    type: 'image_url',
                                    image_url: {
                                        url: image.data
                                    }
                                }
                            ]
                        }]
                    })
                });
                
                if (!response.ok) {
                    throw new Error('OpenAI API request failed');
                }
                
                const result = await response.json();
                return result.choices?.[0]?.message?.content || '';
            }

            async processClaudeAI(image) {
                const apiKey = this.settings.apiKeys['claude-key'] || document.getElementById('claude-key')?.value;
                if (!apiKey) {
                    throw new Error('Claude API key not configured');
                }
                
                // Simulate Claude AI (real implementation would use Anthropic Claude API)
                await new Promise(resolve => setTimeout(resolve, 2000));
                throw new Error('Claude AI not fully implemented - using fallback');
            }

            async processOfflineAI(image) {
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                return "📱 Android AI analysis: This appears to be an inventory item. Please review and update the details manually for accuracy.";
            }

            fillFormFromAI(description) {
                if (!description) return;
                
                // Parse structured AI response
                const nameMatch = description.match(/Name:\s*([^\n,]+)/i);
                if (nameMatch && !document.getElementById('item-name').value) {
                    document.getElementById('item-name').value = nameMatch[1].trim();
                }
                
                const modelMatch = description.match(/Model:\s*([^\n,]+)/i);
                if (modelMatch && !document.getElementById('item-model').value) {
                    document.getElementById('item-model').value = modelMatch[1].trim();
                }
                
                const sizeMatch = description.match(/Size:\s*(Small|Medium|Large|X-Large)/i);
                if (sizeMatch && !document.getElementById('item-size').value) {
                    document.getElementById('item-size').value = sizeMatch[1];
                }
                
                if (!document.getElementById('item-description').value) {
                    document.getElementById('item-description').value = description.trim();
                }
            }

            // ENHANCED SETTINGS MANAGEMENT
            loadSettings() {
                // Update dropdowns with custom values
                this.updateConditionDropdown();
                this.updateFunctionalityDropdown();
                
                // Load other settings
                document.getElementById('auto-save-toggle').checked = this.settings.autoSave !== false;
                document.getElementById('auto-backup-toggle').checked = this.settings.autoBackup === true;
                document.getElementById('validate-apis-toggle').checked = this.settings.validateApis !== false;
                
                // Load sync settings
                document.getElementById('auto-sync-save').checked = this.settings.autoSyncSave === true;
                document.getElementById('sync-images').checked = this.settings.syncImages !== false;
                document.getElementById('sync-settings').checked = this.settings.syncSettings !== false;
                
                const apiKeys = this.settings.apiKeys || {};
                Object.keys(apiKeys).forEach(key => {
                    const element = document.getElementById(key);
                    if (element) {
                        element.value = apiKeys[key] || '';
                    }
                });
            }

            saveSettings() {
                this.settings.customConditions = this.customConditions;
                this.settings.customFunctionalities = this.customFunctionalities;
                
                // Save auto features
                this.settings.autoSave = document.getElementById('auto-save-toggle').checked;
                this.settings.autoBackup = document.getElementById('auto-backup-toggle').checked;
                this.settings.validateApis = document.getElementById('validate-apis-toggle').checked;
                
                // Save sync settings
                this.settings.autoSyncSave = document.getElementById('auto-sync-save').checked;
                this.settings.syncImages = document.getElementById('sync-images').checked;
                this.settings.syncSettings = document.getElementById('sync-settings').checked;
                
                this.settings.apiKeys = {
                    'roboflow-api-key': document.getElementById('roboflow-api-key')?.value || '',
                    'ocrspace-api-key': document.getElementById('ocrspace-api-key')?.value || '',
                    'optiic-api-key': document.getElementById('optiic-api-key')?.value || '',
                    'google-vision-key': document.getElementById('google-vision-key')?.value || '',
                    'openai-key': document.getElementById('openai-key')?.value || '',
                    'gemini-key': document.getElementById('gemini-key')?.value || '',
                    'google-client-id': document.getElementById('google-client-id')?.value || ''
                };

                window.inventoryAppSettings = this.settings;
                this.showNotification('📱 Settings saved successfully!', 'success');
            }

            // DATA MANAGEMENT
            exportDatabase() {
                const data = {
                    items: this.items,
                    places: this.places,
                    garages: this.garages,
                    cabinets: this.cabinets,
                    shelves: this.shelves,
                    boxes: this.boxes,
                    history: this.history,
                    settings: this.settings,
                    exportDate: new Date().toISOString(),
                    platform: 'Android',
                    version: '2.0'
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `android_inventory_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showNotification('📱 Database exported successfully!', 'success');
            }

            importDatabase(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        this.showConfirmDialog('📱 This will replace all current data. Continue?', () => {
                            this.items = data.items || [];
                            this.places = data.places || [];
                            this.garages = data.garages || [];
                            this.cabinets = data.cabinets || [];
                            this.shelves = data.shelves || [];
                            this.boxes = data.boxes || [];
                            this.history = data.history || [];
                            if (data.settings) {
                                this.settings = { ...this.settings, ...data.settings };
                            }
                            
                            this.saveData();
                            this.updateUI();
                            this.showNotification('📱 Database imported successfully!', 'success');
                        });
                    } catch (error) {
                        console.error('❌ Import error:', error);
                        this.showNotification('❌ Failed to import database', 'error');
                    }
                };
                reader.readAsText(file);
                event.target.value = '';
            }

            
async saveToAndroidDirectory() {
                try {
                    // Prefer a previously chosen directory handle kept in memory across the session
                    if (this._androidDirHandle && typeof this._androidDirHandle.getFileHandle === 'function') {
                        const dirHandle = this._androidDirHandle;
                        const data = {
                            items: this.items,
                            places: this.places,
                            garages: this.garages,
                            cabinets: this.cabinets,
                            shelves: this.shelves,
                            boxes: this.boxes,
                            history: this.history,
                            settings: this.settings,
                            exportDate: new Date().toISOString(),
                            platform: 'Android Native',
                            version: '2.0'
                        };
                        const fileName = `android_inventory_${new Date().toISOString().split('T')[0]}.json`;
                        const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(data, null, 2));
                        await writable.close();
                        this.showNotification('📱 Data saved to selected Android folder!', 'success');
                        return;
                    }

                    if ('showDirectoryPicker' in window) {
                        const dirHandle = await window.showDirectoryPicker();
                        const data = {
                            items: this.items,
                            places: this.places,
                            garages: this.garages,
                            cabinets: this.cabinets,
                            shelves: this.shelves,
                            boxes: this.boxes,
                            history: this.history,
                            settings: this.settings,
                            exportDate: new Date().toISOString(),
                            platform: 'Android Native',
                            version: '2.0'
                        };

                        const fileName = `android_inventory_${new Date().toISOString().split('T')[0]}.json`;
                        const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(JSON.stringify(data, null, 2));
                        await writable.close();

                        // remember the chosen folder for this session and store a friendly name
                        this._androidDirHandle = dirHandle;
                        this.settings.androidDirectoryName = dirHandle.name || 'Chosen';
                        try { localStorage.setItem('androidDirectoryChosen', dirHandle.name || 'chosen'); } catch(e){}
                        const chosenEl = document.getElementById('chosen-android-dir');
                        if (chosenEl) chosenEl.textContent = 'Selected folder: ' + (dirHandle.name || 'Selected');

                        this.showNotification('📱 Data saved to Android directory!', 'success');
                    } else {
                        // Fallback to original export behavior (download)
                        this.exportDatabase();
                    }
                } catch (error) {
                    console.error('❌ Android save error:', error);
                    this.showNotification('📱 Using download method instead', 'warning');
                    this.exportDatabase();
                }
            }

            async chooseAndroidDirectory() {
                try {
                    if (!('showDirectoryPicker' in window)) {
                        this.showNotification('Directory picker not supported', 'warning');
                        return;
                    }
                    const dir = await window.showDirectoryPicker();
                    this._androidDirHandle = dir;
                    this.settings.androidDirectoryName = dir.name || 'Chosen';
                    try { localStorage.setItem('androidDirectoryChosen', dir.name || 'chosen'); } catch(e){}
                    const chosenEl = document.getElementById('chosen-android-dir');
                    if (chosenEl) chosenEl.textContent = 'Selected folder: ' + (dir.name || 'Selected');
                    this.showNotification('✅ Folder chosen: ' + (dir.name || 'Selected'), 'success');
                } catch(e) {
                    console.warn('choose dir cancelled', e);
                    this.showNotification('⚠️ Folder selection cancelled', 'warning');
                }
            }

            // UTILITY METHODS
            generateId() {
                return 'android_' + Date.now().toString(36) + Math.random().toString(36).substr(2);
            }

            async fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            }

            showLoading(message = 'Loading...') {
                document.getElementById('loading-text').textContent = message;
                document.getElementById('loading-overlay').classList.remove('hidden');
            }

            hideLoading() {
                document.getElementById('loading-overlay').classList.add('hidden');
            }

            showNotification(message, type = 'success') {
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 z-50 p-2 rounded-lg text-white font-bold shadow-lg text-xs';
                
                switch (type) {
                    case 'success':
                        notification.style.background = '#66bb6a';
                        break;
                    case 'error':
                        notification.style.background = '#ef5350';
                        break;
                    case 'warning':
                        notification.style.background = '#ffab40';
                        break;
                    default:
                        notification.style.background = '#5D5CDE';
                }
                
                notification.innerHTML = `
                    <div class="flex items-center gap-1">
                        <span>${type === 'success' ? '✅' : type === 'error' ? '❌' : '⚠️'}</span>
                        <span>${message}</span>
                    </div>
                `;
                
                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }

            showConfirmDialog(message, onConfirm) {
                const modal = document.createElement('div');
                modal.className = 'android-modal';
                modal.innerHTML = `
                    <div class="android-modal-content">
                        <p class="text-sm mb-4">${message}</p>
                        <div class="flex justify-end space-x-2">
                            <button class="android-btn android-btn-secondary confirm-cancel text-xs">❌ Cancel</button>
                            <button class="android-btn android-btn-danger confirm-ok text-xs">✅ Confirm</button>
                        </div>
                    </div>
                `;
                
                const cancelBtn = modal.querySelector('.confirm-cancel');
                const confirmBtn = modal.querySelector('.confirm-ok');
                
                this.addAndroidTouchEvents(cancelBtn, () => modal.remove());
                this.addAndroidTouchEvents(confirmBtn, () => {
                    modal.remove();
                    onConfirm();
                });
                
                document.body.appendChild(modal);
            }

            showPromptDialog(message, onConfirm, defaultValue = '') {
                const modal = document.createElement('div');
                modal.className = 'android-modal';
                modal.innerHTML = `
                    <div class="android-modal-content">
                        <p class="text-sm mb-3">${message}</p>
                        <input type="text" class="android-input mb-4 prompt-input" value="${defaultValue}" placeholder="Enter text...">
                        <div class="flex justify-end space-x-2">
                            <button class="android-btn android-btn-secondary prompt-cancel text-xs">❌ Cancel</button>
                            <button class="android-btn android-btn-primary prompt-ok text-xs">✅ OK</button>
                        </div>
                    </div>
                `;
                
                const cancelBtn = modal.querySelector('.prompt-cancel');
                const okBtn = modal.querySelector('.prompt-ok');
                const inputField = modal.querySelector('.prompt-input');
                
                this.addAndroidTouchEvents(cancelBtn, () => modal.remove());
                this.addAndroidTouchEvents(okBtn, () => {
                    const value = inputField.value;
                    modal.remove();
                    onConfirm(value);
                });
                
                inputField.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const value = inputField.value;
                        modal.remove();
                        onConfirm(value);
                    }
                });
                
                document.body.appendChild(modal);
                setTimeout(() => {
                    inputField.focus();
                    inputField.select();
                }, 300);
            }
        }

        // Initialize the Android Inventory Manager
        console.log('🤖 Starting Android-Optimized Inventory Manager...');
        const inventoryManager = new InventoryManager();
        window.inventoryManager = inventoryManager;
    </script>



<script>
(function waitAndPatch(){
    function applyPatches() {
        if (!window.inventoryManager) {
            // try again shortly if inventoryManager isn't created yet
            setTimeout(waitAndPatch, 150);
            return;
        }
        const mgr = window.inventoryManager;

        // Set initial font/icon scale from settings or keep default CSS var
        mgr.setFontSize = function(size){
            let scale = 1.0;
            if (size === 'small') scale = 0.9;
            if (size === 'medium') scale = 1.0;
            if (size === 'large') scale = 1.15;
            document.documentElement.style.setProperty('--font-scale', scale);
            document.documentElement.style.setProperty('--icon-scale', scale);
            this.settings.fontScale = scale;
            try { this.saveSettings(); } catch(e){}
            const label = document.getElementById('font-size-label');
            if (label) {
                label.textContent = size.charAt(0).toUpperCase() + size.slice(1);
            }
            this.showNotification('🔠 Font & icon size set to ' + size, 'success');
        };

        // Provide a robust save to Android folder fallback (Website 2 APK Builder Pro doesn't support showDirectoryPicker).
        mgr.saveToAndroidDirectory = async function(){
            try {
                // Try modern directory picker first (some browsers)
                if (window.showDirectoryPicker) {
                    const dir = await window.showDirectoryPicker();
                    const fh = await dir.getFileHandle('inventory-data.json', {create: true});
                    const writable = await fh.createWritable();
                    await writable.write(JSON.stringify({items:this.items, places:this.places, settings:this.settings}, null, 2));
                    await writable.close();
                    this.showNotification('✅ Saved to selected folder', 'success');
                    return;
                }
            } catch(e) {
                console.warn('DirectoryPicker failed or not supported:', e);
            }

            // Fallback: Download-style save to the device Downloads folder
            try {
                const data = JSON.stringify({items:this.items, places:this.places, settings:this.settings}, null, 2);
                const blob = new Blob([data], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const ts = new Date().toISOString().replace(/[:.]/g,'-');
                a.download = 'inventory-data-' + ts + '.json';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                this.showNotification('✅ Download started (check your Downloads folder)', 'success');
            } catch (err) {
                console.error('Save fallback failed', err);
                this.showNotification('❌ Save failed: ' + err.message, 'error');
            }
        };

        // Dropdown population helpers
        mgr.updatePlaceDropdown = function(){
            const el = document.getElementById('item-place');
            if (!el) return;
            const current = el.value;
            el.innerHTML = '<option value="">Select Place...</option>' + (this.places || []).map(p => {
                return `<option value="${p.id}">${p.name}</option>`;
            }).join('');
            if (current) el.value = current;
        };
        mgr.updateGarageDropdown = function(){
            const el = document.getElementById('item-garage');
            if (!el) return;
            const current = el.value;
            // filter garages by selected place if garages have placeId
            const placeId = (document.getElementById('item-place') || {}).value || null;
            let list = this.garages || [];
            if (placeId) {
                list = list.filter(g => !g.placeId || g.placeId === placeId);
            }
            el.innerHTML = '<option value="">Select Garage...</option>' + list.map(g => `<option value="${g.id}">${g.name}</option>`).join('');
            if (current) el.value = current;
        };
        mgr.updateCabinetDropdown = function(){
            const el = document.getElementById('item-cabinet');
            if (!el) return;
            const current = el.value;
            const garageId = (document.getElementById('item-garage') || {}).value || null;
            let list = this.cabinets || [];
            if (garageId) list = list.filter(c => !c.garageId || c.garageId === garageId);
            el.innerHTML = '<option value="">Select Cabinet...</option>' + list.map(c => `<option value="${c.id}">${c.name}</option>`).join('');
            if (current) el.value = current;
        };
        mgr.updateShelfDropdown = function(){
            const el = document.getElementById('item-shelf');
            if (!el) return;
            const current = el.value;
            const cabinetId = (document.getElementById('item-cabinet') || {}).value || null;
            let list = this.shelves || [];
            if (cabinetId) list = list.filter(s => !s.cabinetId || s.cabinetId === cabinetId);
            el.innerHTML = '<option value="">Select Shelf...</option>' + list.map(s => `<option value="${s.id}">${s.name}</option>`).join('');
            if (current) el.value = current;
        };
        mgr.updateBoxDropdown = function(){
            const el = document.getElementById('item-box');
            if (!el) return;
            const current = el.value;
            const shelfId = (document.getElementById('item-shelf') || {}).value || null;
            let list = this.boxes || [];
            if (shelfId) list = list.filter(b => !b.shelfId || b.shelfId === shelfId);
            el.innerHTML = '<option value="">Place directly on shelf (no box/bin)</option>' + list.map(b => `<option value="${b.id}">${b.name}</option>`).join('');
            if (current) el.value = current;
        };

        // Ensure dropdowns populate after data load
        const origLoadData = mgr.loadData && mgr.loadData.bind(mgr);
        if (origLoadData) {
            mgr.loadData = async function(){
                const res = await origLoadData();
                // populate dropdowns after loading
                try {
                    this.updatePlaceDropdown();
                    this.updateGarageDropdown();
                    this.updateCabinetDropdown();
                    this.updateShelfDropdown();
                    this.updateBoxDropdown();
                } catch(e){}
                return res;
            };
        }

        // Also patch saveSettings to maintain fontScale in settings object
        const origSaveSettings = mgr.saveSettings && mgr.saveSettings.bind(mgr);
        if (origSaveSettings) {
            mgr.saveSettings = function(){
                this.settings.fontScale = this.settings.fontScale || parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--font-scale')) || 1.15;
                try { origSaveSettings(); } catch(e){}
            };
        }

        // Set initial UI label
        const label = document.getElementById('font-size-label');
        if (label) {
            const s = mgr.settings && mgr.settings.fontScale ? mgr.settings.fontScale : parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--font-scale')) || 1.15;
            label.textContent = (s >= 1.15) ? 'Large' : (s <= 0.95 ? 'Small' : 'Medium');
        }

        console.log('✅ Patches applied: font sizing, dropdown helpers, save fallback.');
    }

    // Exponential backoff for inventoryManager readiness
    let attempts = 0;
    function waitAndPatch(){
        attempts++;
        if (window.inventoryManager && window.inventoryManager.updatePlaceDropdown) {
            applyPatches();
            return;
        }
        if (window.inventoryManager && !window.inventoryManager.updatePlaceDropdown) {
            applyPatches();
            return;
        }
        if (attempts < 40) {
            setTimeout(waitAndPatch, 150);
        } else {
            console.warn('Could not find inventoryManager to patch after multiple attempts.');
        }
    }
    waitAndPatch();
})();
</script>

<script>
// Setup: wire up Choose Android Folder button (if present)
try {
  document.addEventListener('DOMContentLoaded', function(){
    const chooseBtn = document.getElementById('choose-android-dir');
    if (chooseBtn) chooseBtn.addEventListener('click', function(e){
      if (window.inventoryManager && typeof window.inventoryManager.chooseAndroidDirectory==='function') {
        window.inventoryManager.chooseAndroidDirectory();
      }
    });
    // show previously chosen folder name if present
    try {
      const name = localStorage.getItem('androidDirectoryChosen') || (window.inventoryManager && window.inventoryManager.settings && window.inventoryManager.settings.androidDirectoryName);
      const el = document.getElementById('chosen-android-dir');
      if (el && name) el.textContent = 'Selected folder: ' + name;
    }catch(e){}
  });
} catch(e){ console.warn(e); }

if('serviceWorker' in navigator){window.addEventListener('load',()=>{navigator.serviceWorker.register('/service-worker.js').catch(e=>console.warn('SW failed',e));});}
</script>

<script>
// PWA helper: persist last-opened place and render shelves
(function(){
  function apply(){
    if(!window.inventoryManager) return false;
    const mgr = window.inventoryManager;
    mgr.renderShelvesList = mgr.renderShelvesList || function(){
      const id='shelves-list'; let c=document.getElementById(id);
      if(!c){ const loc=document.getElementById('locations-tab'); if(loc){ const card=document.createElement('div'); card.className='android-card'; card.innerHTML='<h3 class="text-lg font-bold mb-2">Shelves</h3><div id="'+id+'" class="space-y-1"></div>'; loc.appendChild(card); c=document.getElementById(id);} }
      if(!c) return;
      c.innerHTML='';
      (this.shelves||[]).forEach(s=>{ const d=document.createElement('details'); const sm=document.createElement('summary'); sm.textContent=s.name||('Shelf '+s.id); d.appendChild(sm); const desc=document.createElement('div'); desc.className='pl-3 text-sm opacity-80'; desc.textContent=s.description||''; d.appendChild(desc); c.appendChild(d); });
    };
    if(mgr.loadData){ const orig=mgr.loadData.bind(mgr); mgr.loadData=async function(){ const r=await orig(); try{ this.updatePlaceDropdown&&this.updatePlaceDropdown(); this.updateGarageDropdown&&this.updateGarageDropdown(); this.updateCabinetDropdown&&this.updateCabinetDropdown(); this.updateShelfDropdown&&this.updateShelfDropdown(); this.updateBoxDropdown&&this.updateBoxDropdown(); const last=this.settings&& (this.settings.lastOpenedPlaceId||this.settings.lastOpenPlaceId); if(last){ const el=document.getElementById('item-place'); if(el) el.value=last;} this.renderShelvesList&&this.renderShelvesList(); }catch(e){} return r; }; }
    const pe=document.getElementById('item-place'); if(pe){ pe.addEventListener('change', (e)=>{ try{ if(window.inventoryManager&&window.inventoryManager.settings){ window.inventoryManager.settings.lastOpenedPlaceId=e.target.value; window.inventoryManager.saveSettings&&window.inventoryManager.saveSettings(); } }catch(e){} }); }
    try{ mgr.renderShelvesList&&mgr.renderShelvesList(); }catch(e){};
    return true;
  }
  let tries=0; (function w(){ tries++; if(apply()) return; if(tries<60) setTimeout(w,200); else console.warn('PWA helper: inventoryManager not found'); })();
})();
</script>

</body></html>